{"ast":null,"code":"\"use strict\";\n\nvar _sliceInstanceProperty2 = require(\"@babel/runtime-corejs3/core-js-stable/instance/slice\");\nvar _Array$from = require(\"@babel/runtime-corejs3/core-js-stable/array/from\");\nvar _Symbol = require(\"@babel/runtime-corejs3/core-js-stable/symbol\");\nvar _getIteratorMethod = require(\"@babel/runtime-corejs3/core-js/get-iterator-method\");\nvar _Array$isArray2 = require(\"@babel/runtime-corejs3/core-js-stable/array/is-array\");\nvar _Object$keys2 = require(\"@babel/runtime-corejs3/core-js-stable/object/keys\");\nvar _Object$getOwnPropertySymbols = require(\"@babel/runtime-corejs3/core-js-stable/object/get-own-property-symbols\");\nvar _filterInstanceProperty = require(\"@babel/runtime-corejs3/core-js-stable/instance/filter\");\nvar _Object$getOwnPropertyDescriptor = require(\"@babel/runtime-corejs3/core-js-stable/object/get-own-property-descriptor\");\nvar _forEachInstanceProperty = require(\"@babel/runtime-corejs3/core-js-stable/instance/for-each\");\nvar _Object$getOwnPropertyDescriptors = require(\"@babel/runtime-corejs3/core-js-stable/object/get-own-property-descriptors\");\nvar _Object$defineProperties = require(\"@babel/runtime-corejs3/core-js-stable/object/define-properties\");\nvar _Object$defineProperty = require(\"@babel/runtime-corejs3/core-js-stable/object/define-property\");\nvar _interopRequireDefault = require(\"@babel/runtime-corejs3/helpers/interopRequireDefault\");\n_Object$defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.default = void 0;\nvar _slicedToArray2 = _interopRequireDefault(require(\"@babel/runtime-corejs3/helpers/slicedToArray\"));\nvar _typeof2 = _interopRequireDefault(require(\"@babel/runtime-corejs3/helpers/typeof\"));\nvar _classCallCheck2 = _interopRequireDefault(require(\"@babel/runtime-corejs3/helpers/classCallCheck\"));\nvar _createClass2 = _interopRequireDefault(require(\"@babel/runtime-corejs3/helpers/createClass\"));\nvar _defineProperty2 = _interopRequireDefault(require(\"@babel/runtime-corejs3/helpers/defineProperty\"));\nvar _map = _interopRequireDefault(require(\"@babel/runtime-corejs3/core-js-stable/map\"));\nvar _includes = _interopRequireDefault(require(\"@babel/runtime-corejs3/core-js-stable/instance/includes\"));\nvar _every = _interopRequireDefault(require(\"@babel/runtime-corejs3/core-js-stable/instance/every\"));\nvar _entries = _interopRequireDefault(require(\"@babel/runtime-corejs3/core-js-stable/instance/entries\"));\nvar _assign = _interopRequireDefault(require(\"@babel/runtime-corejs3/core-js-stable/object/assign\"));\nvar _slice = _interopRequireDefault(require(\"@babel/runtime-corejs3/core-js-stable/instance/slice\"));\nvar _keys = _interopRequireDefault(require(\"@babel/runtime-corejs3/core-js-stable/object/keys\"));\nvar _isArray = _interopRequireDefault(require(\"@babel/runtime-corejs3/core-js-stable/array/is-array\"));\nvar _ParseRole = _interopRequireDefault(require(\"./ParseRole\"));\nvar _ParseUser = _interopRequireDefault(require(\"./ParseUser\"));\nfunction ownKeys(object, enumerableOnly) {\n  var keys = _Object$keys2(object);\n  if (_Object$getOwnPropertySymbols) {\n    var symbols = _Object$getOwnPropertySymbols(object);\n    enumerableOnly && (symbols = _filterInstanceProperty(symbols).call(symbols, function (sym) {\n      return _Object$getOwnPropertyDescriptor(object, sym).enumerable;\n    })), keys.push.apply(keys, symbols);\n  }\n  return keys;\n}\nfunction _objectSpread(target) {\n  for (var i = 1; i < arguments.length; i++) {\n    var _context3, _context4;\n    var source = null != arguments[i] ? arguments[i] : {};\n    i % 2 ? _forEachInstanceProperty(_context3 = ownKeys(Object(source), !0)).call(_context3, function (key) {\n      (0, _defineProperty2.default)(target, key, source[key]);\n    }) : _Object$getOwnPropertyDescriptors ? _Object$defineProperties(target, _Object$getOwnPropertyDescriptors(source)) : _forEachInstanceProperty(_context4 = ownKeys(Object(source))).call(_context4, function (key) {\n      _Object$defineProperty(target, key, _Object$getOwnPropertyDescriptor(source, key));\n    });\n  }\n  return target;\n}\nfunction _createForOfIteratorHelper(o, allowArrayLike) {\n  var it = typeof _Symbol !== \"undefined\" && _getIteratorMethod(o) || o[\"@@iterator\"];\n  if (!it) {\n    if (_Array$isArray2(o) || (it = _unsupportedIterableToArray(o)) || allowArrayLike && o && typeof o.length === \"number\") {\n      if (it) o = it;\n      var i = 0;\n      var F = function () {};\n      return {\n        s: F,\n        n: function () {\n          if (i >= o.length) return {\n            done: true\n          };\n          return {\n            done: false,\n            value: o[i++]\n          };\n        },\n        e: function (_e) {\n          throw _e;\n        },\n        f: F\n      };\n    }\n    throw new TypeError(\"Invalid attempt to iterate non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\");\n  }\n  var normalCompletion = true,\n    didErr = false,\n    err;\n  return {\n    s: function () {\n      it = it.call(o);\n    },\n    n: function () {\n      var step = it.next();\n      normalCompletion = step.done;\n      return step;\n    },\n    e: function (_e2) {\n      didErr = true;\n      err = _e2;\n    },\n    f: function () {\n      try {\n        if (!normalCompletion && it.return != null) it.return();\n      } finally {\n        if (didErr) throw err;\n      }\n    }\n  };\n}\nfunction _unsupportedIterableToArray(o, minLen) {\n  var _context2;\n  if (!o) return;\n  if (typeof o === \"string\") return _arrayLikeToArray(o, minLen);\n  var n = _sliceInstanceProperty2(_context2 = Object.prototype.toString.call(o)).call(_context2, 8, -1);\n  if (n === \"Object\" && o.constructor) n = o.constructor.name;\n  if (n === \"Map\" || n === \"Set\") return _Array$from(o);\n  if (n === \"Arguments\" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen);\n}\nfunction _arrayLikeToArray(arr, len) {\n  if (len == null || len > arr.length) len = arr.length;\n  for (var i = 0, arr2 = new Array(len); i < len; i++) arr2[i] = arr[i];\n  return arr2;\n} /**\n   * @flow\n   */\n/*:: type Entity = Entity;*/\n/*:: type UsersMap = { [userId: string]: boolean | any };*/\n/*:: export type PermissionsMap = { [permission: string]: UsersMap };*/\nvar PUBLIC_KEY = '*';\nvar VALID_PERMISSIONS /*: Map<string, UsersMap>*/ = new _map.default(\n  /*:: <string, UsersMap>*/\n);\nVALID_PERMISSIONS.set('get', {});\nVALID_PERMISSIONS.set('find', {});\nVALID_PERMISSIONS.set('count', {});\nVALID_PERMISSIONS.set('create', {});\nVALID_PERMISSIONS.set('update', {});\nVALID_PERMISSIONS.set('delete', {});\nVALID_PERMISSIONS.set('addField', {});\nvar VALID_PERMISSIONS_EXTENDED /*: Map<string, UsersMap>*/ = new _map.default(\n  /*:: <string, UsersMap>*/\n);\nVALID_PERMISSIONS_EXTENDED.set('protectedFields', {});\n\n/**\n * Creates a new CLP.\n * If no argument is given, the CLP has no permissions for anyone.\n * If the argument is a Parse.User or Parse.Role, the CLP will have read and write\n *   permission for only that user or role.\n * If the argument is any other JSON object, that object will be interpretted\n *   as a serialized CLP created with toJSON().\n *\n * <p>A CLP, or Class Level Permissions can be added to any\n * <code>Parse.Schema</code> to restrict access to only a subset of users\n * of your application.</p>\n *\n * <p>\n * For get/count/find/create/update/delete/addField using the following functions:\n *\n * Entity is type Parse.User or Parse.Role or string\n * Role is type Parse.Role or Name of Parse.Role\n *\n * getGetRequiresAuthentication()\n * setGetRequiresAuthentication(allowed: boolean)\n * getGetPointerFields()\n * setGetPointerFields(pointerFields: string[])\n * getGetAccess(entity: Entity)\n * setGetAccess(entity: Entity, allowed: boolean)\n * getPublicGetAccess()\n * setPublicGetAccess(allowed: boolean)\n * getRoleGetAccess(role: Role)\n * setRoleGetAccess(role: Role, allowed: boolean)\n * getFindRequiresAuthentication()\n * setFindRequiresAuthentication(allowed: boolean)\n * getFindPointerFields()\n * setFindPointerFields(pointerFields: string[])\n * getFindAccess(entity: Entity)\n * setFindAccess(entity: Entity, allowed: boolean)\n * getPublicFindAccess()\n * setPublicFindAccess(allowed: boolean)\n * getRoleFindAccess(role: Role)\n * setRoleFindAccess(role: Role, allowed: boolean)\n * getCountRequiresAuthentication()\n * setCountRequiresAuthentication(allowed: boolean)\n * getCountPointerFields()\n * setCountPointerFields(pointerFields: string[])\n * getCountAccess(entity: Entity)\n * setCountAccess(entity: Entity, allowed: boolean)\n * getPublicCountAccess()\n * setPublicCountAccess(allowed: boolean)\n * getRoleCountAccess(role: Role)\n * setRoleCountAccess(role: Role, allowed: boolean)\n * getCreateRequiresAuthentication()\n * setCreateRequiresAuthentication(allowed: boolean)\n * getCreatePointerFields()\n * setCreatePointerFields(pointerFields: string[])\n * getCreateAccess(entity: Entity)\n * setCreateAccess(entity: Entity, allowed: boolean)\n * getPublicCreateAccess()\n * setPublicCreateAccess(allowed: Boolean)\n * getRoleCreateAccess(role: Role)\n * setRoleCreateAccess(role: Role, allowed: boolean)\n * getUpdateRequiresAuthentication()\n * setUpdateRequiresAuthentication(allowed: boolean)\n * getUpdatePointerFields()\n * setUpdatePointerFields(pointerFields: string[])\n * getUpdateAccess(entity: Entity)\n * setUpdateAccess(entity: Entity, allowed: boolean)\n * getPublicUpdateAccess()\n * setPublicUpdateAccess(allowed: boolean)\n * getRoleUpdateAccess(role: Role)\n * setRoleUpdateAccess(role: Role, allowed: boolean)\n * getDeleteRequiresAuthentication()\n * setDeleteRequiresAuthentication(allowed: boolean)\n * getDeletePointerFields()\n * setDeletePointerFields(pointerFields: string[])\n * getDeleteAccess(entity: Entity)\n * setDeleteAccess(entity: Entity, allowed: boolean)\n * getPublicDeleteAccess()\n * setPublicDeleteAccess(allowed: boolean)\n * getRoleDeleteAccess(role: Role)\n * setRoleDeleteAccess(role: Role, allowed: boolean)\n * getAddFieldRequiresAuthentication()\n * setAddFieldRequiresAuthentication(allowed: boolean)\n * getAddFieldPointerFields()\n * setAddFieldPointerFields(pointerFields: string[])\n * getAddFieldAccess(entity: Entity)\n * setAddFieldAccess(entity: Entity, allowed: boolean)\n * getPublicAddFieldAccess()\n * setPublicAddFieldAccess(allowed: boolean)\n * getRoleAddFieldAccess(role: Role)\n * setRoleAddFieldAccess(role: Role, allowed: boolean)\n * </p>\n *\n * @alias Parse.CLP\n */\nvar ParseCLP = /*#__PURE__*/function () {\n  /**\n   * @param {(Parse.User | Parse.Role | object)} userId The user to initialize the CLP for\n   */\n  function ParseCLP(userId /*: ParseUser | ParseRole | PermissionsMap*/) {\n    var _this = this;\n    (0, _classCallCheck2.default)(this, ParseCLP);\n    (0, _defineProperty2.default)(this, \"permissionsMap\", void 0);\n    this.permissionsMap = {};\n    // Initialize permissions Map with default permissions\n    var _iterator = _createForOfIteratorHelper((0, _entries.default)(VALID_PERMISSIONS).call(VALID_PERMISSIONS)),\n      _step;\n    try {\n      var _loop = function _loop() {\n        var _step$value = (0, _slicedToArray2.default)(_step.value, 2),\n          operation = _step$value[0],\n          group = _step$value[1];\n        _this.permissionsMap[operation] = (0, _assign.default)({}, group);\n        var action = operation.charAt(0).toUpperCase() + (0, _slice.default)(operation).call(operation, 1);\n        _this[\"get\".concat(action, \"RequiresAuthentication\")] = function () {\n          return this._getAccess(operation, 'requiresAuthentication');\n        };\n        _this[\"set\".concat(action, \"RequiresAuthentication\")] = function (allowed) {\n          this._setAccess(operation, 'requiresAuthentication', allowed);\n        };\n        _this[\"get\".concat(action, \"PointerFields\")] = function () {\n          return this._getAccess(operation, 'pointerFields', false);\n        };\n        _this[\"set\".concat(action, \"PointerFields\")] = function (pointerFields) {\n          this._setArrayAccess(operation, 'pointerFields', pointerFields);\n        };\n        _this[\"get\".concat(action, \"Access\")] = function (entity) {\n          return this._getAccess(operation, entity);\n        };\n        _this[\"set\".concat(action, \"Access\")] = function (entity, allowed) {\n          this._setAccess(operation, entity, allowed);\n        };\n        _this[\"getPublic\".concat(action, \"Access\")] = function () {\n          return this[\"get\".concat(action, \"Access\")](PUBLIC_KEY);\n        };\n        _this[\"setPublic\".concat(action, \"Access\")] = function (allowed) {\n          this[\"set\".concat(action, \"Access\")](PUBLIC_KEY, allowed);\n        };\n        _this[\"getRole\".concat(action, \"Access\")] = function (role) {\n          return this[\"get\".concat(action, \"Access\")](this._getRoleName(role));\n        };\n        _this[\"setRole\".concat(action, \"Access\")] = function (role, allowed) {\n          this[\"set\".concat(action, \"Access\")](this._getRoleName(role), allowed);\n        };\n      };\n      for (_iterator.s(); !(_step = _iterator.n()).done;) {\n        _loop();\n      }\n      // Initialize permissions Map with default extended permissions\n    } catch (err) {\n      _iterator.e(err);\n    } finally {\n      _iterator.f();\n    }\n    var _iterator2 = _createForOfIteratorHelper((0, _entries.default)(VALID_PERMISSIONS_EXTENDED).call(VALID_PERMISSIONS_EXTENDED)),\n      _step2;\n    try {\n      for (_iterator2.s(); !(_step2 = _iterator2.n()).done;) {\n        var _step2$value = (0, _slicedToArray2.default)(_step2.value, 2),\n          operation = _step2$value[0],\n          group = _step2$value[1];\n        this.permissionsMap[operation] = (0, _assign.default)({}, group);\n      }\n    } catch (err) {\n      _iterator2.e(err);\n    } finally {\n      _iterator2.f();\n    }\n    if (userId && (0, _typeof2.default)(userId) === 'object') {\n      if (userId instanceof _ParseUser.default) {\n        this.setReadAccess(userId, true);\n        this.setWriteAccess(userId, true);\n      } else if (userId instanceof _ParseRole.default) {\n        this.setRoleReadAccess(userId, true);\n        this.setRoleWriteAccess(userId, true);\n      } else {\n        for (var _permission in userId) {\n          var _context;\n          var users = userId[_permission];\n          var isValidPermission = !!VALID_PERMISSIONS.get(_permission);\n          var isValidPermissionExtended = !!VALID_PERMISSIONS_EXTENDED.get(_permission);\n          var isValidGroupPermission = (0, _includes.default)(_context = ['readUserFields', 'writeUserFields']).call(_context, _permission);\n          if (typeof _permission !== 'string' || !(isValidPermission || isValidPermissionExtended || isValidGroupPermission)) {\n            throw new TypeError('Tried to create an CLP with an invalid permission type.');\n          }\n          if (isValidGroupPermission) {\n            if ((0, _every.default)(users).call(users, function (pointer) {\n              return typeof pointer === 'string';\n            })) {\n              this.permissionsMap[_permission] = users;\n              continue;\n            } else {\n              throw new TypeError('Tried to create an CLP with an invalid permission value.');\n            }\n          }\n          for (var user in users) {\n            var allowed = users[user];\n            if (typeof allowed !== 'boolean' && !isValidPermissionExtended && user !== 'pointerFields') {\n              throw new TypeError('Tried to create an CLP with an invalid permission value.');\n            }\n            this.permissionsMap[_permission][user] = allowed;\n          }\n        }\n      }\n    } else if (typeof userId === 'function') {\n      throw new TypeError('ParseCLP constructed with a function. Did you forget ()?');\n    }\n  }\n\n  /**\n   * Returns a JSON-encoded version of the CLP.\n   *\n   * @returns {object}\n   */\n  (0, _createClass2.default)(ParseCLP, [{\n    key: \"toJSON\",\n    value: function toJSON() /*: PermissionsMap*/{\n      return _objectSpread({}, this.permissionsMap);\n    }\n\n    /**\n     * Returns whether this CLP is equal to another object\n     *\n     * @param other The other object to compare to\n     * @returns {boolean}\n     */\n  }, {\n    key: \"equals\",\n    value: function equals(other /*: ParseCLP*/) /*: boolean*/{\n      if (!(other instanceof ParseCLP)) {\n        return false;\n      }\n      var permissions = (0, _keys.default)(this.permissionsMap);\n      var otherPermissions = (0, _keys.default)(other.permissionsMap);\n      if (permissions.length !== otherPermissions.length) {\n        return false;\n      }\n      for (var _permission2 in this.permissionsMap) {\n        if (!other.permissionsMap[_permission2]) {\n          return false;\n        }\n        var users = (0, _keys.default)(this.permissionsMap[_permission2]);\n        var otherUsers = (0, _keys.default)(other.permissionsMap[_permission2]);\n        if (users.length !== otherUsers.length) {\n          return false;\n        }\n        for (var user in this.permissionsMap[_permission2]) {\n          if (!other.permissionsMap[_permission2][user]) {\n            return false;\n          }\n          if (this.permissionsMap[_permission2][user] !== other.permissionsMap[_permission2][user]) {\n            return false;\n          }\n        }\n      }\n      return true;\n    }\n  }, {\n    key: \"_getRoleName\",\n    value: function _getRoleName(role /*: ParseRole | string*/) /*: string*/{\n      var name = role;\n      if (role instanceof _ParseRole.default) {\n        // Normalize to the String name\n        name = role.getName();\n      }\n      if (typeof name !== 'string') {\n        throw new TypeError('role must be a Parse.Role or a String');\n      }\n      return \"role:\".concat(name);\n    }\n  }, {\n    key: \"_parseEntity\",\n    value: function _parseEntity(entity /*: Entity*/) {\n      var userId = entity;\n      if (userId instanceof _ParseUser.default) {\n        userId = userId.id;\n        if (!userId) {\n          throw new Error('Cannot get access for a Parse.User without an id.');\n        }\n      } else if (userId instanceof _ParseRole.default) {\n        userId = this._getRoleName(userId);\n      }\n      if (typeof userId !== 'string') {\n        throw new TypeError('userId must be a string.');\n      }\n      return userId;\n    }\n  }, {\n    key: \"_setAccess\",\n    value: function _setAccess(permission /*: string*/, userId /*: Entity*/, allowed /*: boolean*/) {\n      userId = this._parseEntity(userId);\n      if (typeof allowed !== 'boolean') {\n        throw new TypeError('allowed must be either true or false.');\n      }\n      var permissions = this.permissionsMap[permission][userId];\n      if (!permissions) {\n        if (!allowed) {\n          // The user already doesn't have this permission, so no action is needed\n          return;\n        } else {\n          this.permissionsMap[permission][userId] = {};\n        }\n      }\n      if (allowed) {\n        this.permissionsMap[permission][userId] = true;\n      } else {\n        delete this.permissionsMap[permission][userId];\n      }\n    }\n  }, {\n    key: \"_getAccess\",\n    value: function _getAccess(permission /*: string*/, userId /*: Entity*/) /*: boolean | string[]*/{\n      var returnBoolean = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : true;\n      userId = this._parseEntity(userId);\n      var permissions = this.permissionsMap[permission][userId];\n      if (returnBoolean) {\n        if (!permissions) {\n          return false;\n        }\n        return !!this.permissionsMap[permission][userId];\n      }\n      return permissions;\n    }\n  }, {\n    key: \"_setArrayAccess\",\n    value: function _setArrayAccess(permission /*: string*/, userId /*: Entity*/, fields /*: string*/) {\n      userId = this._parseEntity(userId);\n      var permissions = this.permissionsMap[permission][userId];\n      if (!permissions) {\n        this.permissionsMap[permission][userId] = [];\n      }\n      if (!fields || (0, _isArray.default)(fields) && fields.length === 0) {\n        delete this.permissionsMap[permission][userId];\n      } else if ((0, _isArray.default)(fields) && (0, _every.default)(fields).call(fields, function (field) {\n        return typeof field === 'string';\n      })) {\n        this.permissionsMap[permission][userId] = fields;\n      } else {\n        throw new TypeError('fields must be an array of strings or undefined.');\n      }\n    }\n  }, {\n    key: \"_setGroupPointerPermission\",\n    value: function _setGroupPointerPermission(operation /*: string*/, pointerFields /*: string[]*/) {\n      var fields = this.permissionsMap[operation];\n      if (!fields) {\n        this.permissionsMap[operation] = [];\n      }\n      if (!pointerFields || (0, _isArray.default)(pointerFields) && pointerFields.length === 0) {\n        delete this.permissionsMap[operation];\n      } else if ((0, _isArray.default)(pointerFields) && (0, _every.default)(pointerFields).call(pointerFields, function (field) {\n        return typeof field === 'string';\n      })) {\n        this.permissionsMap[operation] = pointerFields;\n      } else {\n        throw new TypeError(\"\".concat(operation, \".pointerFields must be an array of strings or undefined.\"));\n      }\n    }\n  }, {\n    key: \"_getGroupPointerPermissions\",\n    value: function _getGroupPointerPermissions(operation /*: string*/) /*: string[]*/{\n      return this.permissionsMap[operation];\n    }\n\n    /**\n     * Sets user pointer fields to allow permission for get/count/find operations.\n     *\n     * @param {string[]} pointerFields User pointer fields\n     */\n  }, {\n    key: \"setReadUserFields\",\n    value: function setReadUserFields(pointerFields /*: string[]*/) {\n      this._setGroupPointerPermission('readUserFields', pointerFields);\n    }\n\n    /**\n     * @returns {string[]} User pointer fields\n     */\n  }, {\n    key: \"getReadUserFields\",\n    value: function getReadUserFields() /*: string[]*/{\n      return this._getGroupPointerPermissions('readUserFields');\n    }\n\n    /**\n     * Sets user pointer fields to allow permission for create/delete/update/addField operations\n     *\n     * @param {string[]} pointerFields User pointer fields\n     */\n  }, {\n    key: \"setWriteUserFields\",\n    value: function setWriteUserFields(pointerFields /*: string[]*/) {\n      this._setGroupPointerPermission('writeUserFields', pointerFields);\n    }\n\n    /**\n     * @returns {string[]} User pointer fields\n     */\n  }, {\n    key: \"getWriteUserFields\",\n    value: function getWriteUserFields() /*: string[]*/{\n      return this._getGroupPointerPermissions('writeUserFields');\n    }\n\n    /**\n     * Sets whether the given user is allowed to retrieve fields from this class.\n     *\n     * @param userId An instance of Parse.User or its objectId.\n     * @param {string[]} fields fields to be protected\n     */\n  }, {\n    key: \"setProtectedFields\",\n    value: function setProtectedFields(userId /*: Entity*/, fields /*: string[]*/) {\n      this._setArrayAccess('protectedFields', userId, fields);\n    }\n\n    /**\n     * Returns array of fields are accessable to this user.\n     *\n     * @param userId An instance of Parse.User or its objectId, or a Parse.Role.\n     * @returns {string[]}\n     */\n  }, {\n    key: \"getProtectedFields\",\n    value: function getProtectedFields(userId /*: Entity*/) /*: string[]*/{\n      return this._getAccess('protectedFields', userId, false);\n    }\n\n    /**\n     * Sets whether the given user is allowed to read from this class.\n     *\n     * @param userId An instance of Parse.User or its objectId.\n     * @param {boolean} allowed whether that user should have read access.\n     */\n  }, {\n    key: \"setReadAccess\",\n    value: function setReadAccess(userId /*: Entity*/, allowed /*: boolean*/) {\n      this._setAccess('find', userId, allowed);\n      this._setAccess('get', userId, allowed);\n      this._setAccess('count', userId, allowed);\n    }\n\n    /**\n     * Get whether the given user id is *explicitly* allowed to read from this class.\n     * Even if this returns false, the user may still be able to access it if\n     * getPublicReadAccess returns true or a role that the user belongs to has\n     * write access.\n     *\n     * @param userId An instance of Parse.User or its objectId, or a Parse.Role.\n     * @returns {boolean}\n     */\n  }, {\n    key: \"getReadAccess\",\n    value: function getReadAccess(userId /*: Entity*/) /*: boolean*/{\n      return this._getAccess('find', userId) && this._getAccess('get', userId) && this._getAccess('count', userId);\n    }\n\n    /**\n     * Sets whether the given user id is allowed to write to this class.\n     *\n     * @param userId An instance of Parse.User or its objectId, or a Parse.Role..\n     * @param {boolean} allowed Whether that user should have write access.\n     */\n  }, {\n    key: \"setWriteAccess\",\n    value: function setWriteAccess(userId /*: Entity*/, allowed /*: boolean*/) {\n      this._setAccess('create', userId, allowed);\n      this._setAccess('update', userId, allowed);\n      this._setAccess('delete', userId, allowed);\n      this._setAccess('addField', userId, allowed);\n    }\n\n    /**\n     * Gets whether the given user id is *explicitly* allowed to write to this class.\n     * Even if this returns false, the user may still be able to write it if\n     * getPublicWriteAccess returns true or a role that the user belongs to has\n     * write access.\n     *\n     * @param userId An instance of Parse.User or its objectId, or a Parse.Role.\n     * @returns {boolean}\n     */\n  }, {\n    key: \"getWriteAccess\",\n    value: function getWriteAccess(userId /*: Entity*/) /*: boolean*/{\n      return this._getAccess('create', userId) && this._getAccess('update', userId) && this._getAccess('delete', userId) && this._getAccess('addField', userId);\n    }\n\n    /**\n     * Sets whether the public is allowed to read from this class.\n     *\n     * @param {boolean} allowed\n     */\n  }, {\n    key: \"setPublicReadAccess\",\n    value: function setPublicReadAccess(allowed /*: boolean*/) {\n      this.setReadAccess(PUBLIC_KEY, allowed);\n    }\n\n    /**\n     * Gets whether the public is allowed to read from this class.\n     *\n     * @returns {boolean}\n     */\n  }, {\n    key: \"getPublicReadAccess\",\n    value: function getPublicReadAccess() /*: boolean*/{\n      return this.getReadAccess(PUBLIC_KEY);\n    }\n\n    /**\n     * Sets whether the public is allowed to write to this class.\n     *\n     * @param {boolean} allowed\n     */\n  }, {\n    key: \"setPublicWriteAccess\",\n    value: function setPublicWriteAccess(allowed /*: boolean*/) {\n      this.setWriteAccess(PUBLIC_KEY, allowed);\n    }\n\n    /**\n     * Gets whether the public is allowed to write to this class.\n     *\n     * @returns {boolean}\n     */\n  }, {\n    key: \"getPublicWriteAccess\",\n    value: function getPublicWriteAccess() /*: boolean*/{\n      return this.getWriteAccess(PUBLIC_KEY);\n    }\n\n    /**\n     * Sets whether the public is allowed to protect fields in this class.\n     *\n     * @param {string[]} fields\n     */\n  }, {\n    key: \"setPublicProtectedFields\",\n    value: function setPublicProtectedFields(fields /*: string[]*/) {\n      this.setProtectedFields(PUBLIC_KEY, fields);\n    }\n\n    /**\n     * Gets whether the public is allowed to read fields from this class.\n     *\n     * @returns {string[]}\n     */\n  }, {\n    key: \"getPublicProtectedFields\",\n    value: function getPublicProtectedFields() /*: string[]*/{\n      return this.getProtectedFields(PUBLIC_KEY);\n    }\n\n    /**\n     * Gets whether users belonging to the given role are allowed\n     * to read from this class. Even if this returns false, the role may\n     * still be able to write it if a parent role has read access.\n     *\n     * @param role The name of the role, or a Parse.Role object.\n     * @returns {boolean} true if the role has read access. false otherwise.\n     * @throws {TypeError} If role is neither a Parse.Role nor a String.\n     */\n  }, {\n    key: \"getRoleReadAccess\",\n    value: function getRoleReadAccess(role /*: ParseRole | string*/) /*: boolean*/{\n      return this.getReadAccess(this._getRoleName(role));\n    }\n\n    /**\n     * Gets whether users belonging to the given role are allowed\n     * to write to this user. Even if this returns false, the role may\n     * still be able to write it if a parent role has write access.\n     *\n     * @param role The name of the role, or a Parse.Role object.\n     * @returns {boolean} true if the role has write access. false otherwise.\n     * @throws {TypeError} If role is neither a Parse.Role nor a String.\n     */\n  }, {\n    key: \"getRoleWriteAccess\",\n    value: function getRoleWriteAccess(role /*: ParseRole | string*/) /*: boolean*/{\n      return this.getWriteAccess(this._getRoleName(role));\n    }\n\n    /**\n     * Sets whether users belonging to the given role are allowed\n     * to read from this class.\n     *\n     * @param role The name of the role, or a Parse.Role object.\n     * @param {boolean} allowed Whether the given role can read this object.\n     * @throws {TypeError} If role is neither a Parse.Role nor a String.\n     */\n  }, {\n    key: \"setRoleReadAccess\",\n    value: function setRoleReadAccess(role /*: ParseRole | string*/, allowed /*: boolean*/) {\n      this.setReadAccess(this._getRoleName(role), allowed);\n    }\n\n    /**\n     * Sets whether users belonging to the given role are allowed\n     * to write to this class.\n     *\n     * @param role The name of the role, or a Parse.Role object.\n     * @param {boolean} allowed Whether the given role can write this object.\n     * @throws {TypeError} If role is neither a Parse.Role nor a String.\n     */\n  }, {\n    key: \"setRoleWriteAccess\",\n    value: function setRoleWriteAccess(role /*: ParseRole | string*/, allowed /*: boolean*/) {\n      this.setWriteAccess(this._getRoleName(role), allowed);\n    }\n\n    /**\n     * Gets whether users belonging to the given role are allowed\n     * to count to this user. Even if this returns false, the role may\n     * still be able to count it if a parent role has count access.\n     *\n     * @param role The name of the role, or a Parse.Role object.\n     * @returns {string[]}\n     * @throws {TypeError} If role is neither a Parse.Role nor a String.\n     */\n  }, {\n    key: \"getRoleProtectedFields\",\n    value: function getRoleProtectedFields(role /*: ParseRole | string*/) /*: string[]*/{\n      return this.getProtectedFields(this._getRoleName(role));\n    }\n\n    /**\n     * Sets whether users belonging to the given role are allowed\n     * to set access field in this class.\n     *\n     * @param role The name of the role, or a Parse.Role object.\n     * @param {string[]} fields Fields to be protected by Role.\n     * @throws {TypeError} If role is neither a Parse.Role nor a String.\n     */\n  }, {\n    key: \"setRoleProtectedFields\",\n    value: function setRoleProtectedFields(role /*: ParseRole | string*/, fields /*: string[]*/) {\n      this.setProtectedFields(this._getRoleName(role), fields);\n    }\n  }]);\n  return ParseCLP;\n}();\nvar _default = ParseCLP;\nexports.default = _default;","map":{"version":3,"names":["_sliceInstanceProperty2","require","_Array$from","_Symbol","_getIteratorMethod","_Array$isArray2","_Object$keys2","_Object$getOwnPropertySymbols","_filterInstanceProperty","_Object$getOwnPropertyDescriptor","_forEachInstanceProperty","_Object$getOwnPropertyDescriptors","_Object$defineProperties","_Object$defineProperty","_interopRequireDefault","exports","value","default","_slicedToArray2","_typeof2","_classCallCheck2","_createClass2","_defineProperty2","_map","_includes","_every","_entries","_assign","_slice","_keys","_isArray","_ParseRole","_ParseUser","ownKeys","object","enumerableOnly","keys","symbols","call","sym","enumerable","push","apply","_objectSpread","target","i","arguments","length","_context3","_context4","source","Object","key","_createForOfIteratorHelper","o","allowArrayLike","it","_unsupportedIterableToArray","F","s","n","done","e","_e","f","TypeError","normalCompletion","didErr","err","step","next","_e2","return","minLen","_context2","_arrayLikeToArray","prototype","toString","constructor","name","test","arr","len","arr2","Array","PUBLIC_KEY","VALID_PERMISSIONS","set","VALID_PERMISSIONS_EXTENDED","ParseCLP","userId","_this","permissionsMap","_iterator","_step","_loop","_step$value","operation","group","action","charAt","toUpperCase","concat","_getAccess","allowed","_setAccess","pointerFields","_setArrayAccess","entity","role","_getRoleName","_iterator2","_step2","_step2$value","setReadAccess","setWriteAccess","setRoleReadAccess","setRoleWriteAccess","_permission","_context","users","isValidPermission","get","isValidPermissionExtended","isValidGroupPermission","pointer","user","toJSON","equals","other","permissions","otherPermissions","_permission2","otherUsers","getName","_parseEntity","id","Error","permission","returnBoolean","undefined","fields","field","_setGroupPointerPermission","_getGroupPointerPermissions","setReadUserFields","getReadUserFields","setWriteUserFields","getWriteUserFields","setProtectedFields","getProtectedFields","getReadAccess","getWriteAccess","setPublicReadAccess","getPublicReadAccess","setPublicWriteAccess","getPublicWriteAccess","setPublicProtectedFields","getPublicProtectedFields","getRoleReadAccess","getRoleWriteAccess","getRoleProtectedFields","setRoleProtectedFields","_default"],"sources":["/home/mspadafo/compsci/MWD/mwd-pogg/poggcopy/pogg/node_modules/parse/lib/browser/ParseCLP.js"],"sourcesContent":["\"use strict\";\n\nvar _sliceInstanceProperty2 = require(\"@babel/runtime-corejs3/core-js-stable/instance/slice\");\nvar _Array$from = require(\"@babel/runtime-corejs3/core-js-stable/array/from\");\nvar _Symbol = require(\"@babel/runtime-corejs3/core-js-stable/symbol\");\nvar _getIteratorMethod = require(\"@babel/runtime-corejs3/core-js/get-iterator-method\");\nvar _Array$isArray2 = require(\"@babel/runtime-corejs3/core-js-stable/array/is-array\");\nvar _Object$keys2 = require(\"@babel/runtime-corejs3/core-js-stable/object/keys\");\nvar _Object$getOwnPropertySymbols = require(\"@babel/runtime-corejs3/core-js-stable/object/get-own-property-symbols\");\nvar _filterInstanceProperty = require(\"@babel/runtime-corejs3/core-js-stable/instance/filter\");\nvar _Object$getOwnPropertyDescriptor = require(\"@babel/runtime-corejs3/core-js-stable/object/get-own-property-descriptor\");\nvar _forEachInstanceProperty = require(\"@babel/runtime-corejs3/core-js-stable/instance/for-each\");\nvar _Object$getOwnPropertyDescriptors = require(\"@babel/runtime-corejs3/core-js-stable/object/get-own-property-descriptors\");\nvar _Object$defineProperties = require(\"@babel/runtime-corejs3/core-js-stable/object/define-properties\");\nvar _Object$defineProperty = require(\"@babel/runtime-corejs3/core-js-stable/object/define-property\");\nvar _interopRequireDefault = require(\"@babel/runtime-corejs3/helpers/interopRequireDefault\");\n_Object$defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.default = void 0;\nvar _slicedToArray2 = _interopRequireDefault(require(\"@babel/runtime-corejs3/helpers/slicedToArray\"));\nvar _typeof2 = _interopRequireDefault(require(\"@babel/runtime-corejs3/helpers/typeof\"));\nvar _classCallCheck2 = _interopRequireDefault(require(\"@babel/runtime-corejs3/helpers/classCallCheck\"));\nvar _createClass2 = _interopRequireDefault(require(\"@babel/runtime-corejs3/helpers/createClass\"));\nvar _defineProperty2 = _interopRequireDefault(require(\"@babel/runtime-corejs3/helpers/defineProperty\"));\nvar _map = _interopRequireDefault(require(\"@babel/runtime-corejs3/core-js-stable/map\"));\nvar _includes = _interopRequireDefault(require(\"@babel/runtime-corejs3/core-js-stable/instance/includes\"));\nvar _every = _interopRequireDefault(require(\"@babel/runtime-corejs3/core-js-stable/instance/every\"));\nvar _entries = _interopRequireDefault(require(\"@babel/runtime-corejs3/core-js-stable/instance/entries\"));\nvar _assign = _interopRequireDefault(require(\"@babel/runtime-corejs3/core-js-stable/object/assign\"));\nvar _slice = _interopRequireDefault(require(\"@babel/runtime-corejs3/core-js-stable/instance/slice\"));\nvar _keys = _interopRequireDefault(require(\"@babel/runtime-corejs3/core-js-stable/object/keys\"));\nvar _isArray = _interopRequireDefault(require(\"@babel/runtime-corejs3/core-js-stable/array/is-array\"));\nvar _ParseRole = _interopRequireDefault(require(\"./ParseRole\"));\nvar _ParseUser = _interopRequireDefault(require(\"./ParseUser\"));\nfunction ownKeys(object, enumerableOnly) {\n  var keys = _Object$keys2(object);\n  if (_Object$getOwnPropertySymbols) {\n    var symbols = _Object$getOwnPropertySymbols(object);\n    enumerableOnly && (symbols = _filterInstanceProperty(symbols).call(symbols, function (sym) {\n      return _Object$getOwnPropertyDescriptor(object, sym).enumerable;\n    })), keys.push.apply(keys, symbols);\n  }\n  return keys;\n}\nfunction _objectSpread(target) {\n  for (var i = 1; i < arguments.length; i++) {\n    var _context3, _context4;\n    var source = null != arguments[i] ? arguments[i] : {};\n    i % 2 ? _forEachInstanceProperty(_context3 = ownKeys(Object(source), !0)).call(_context3, function (key) {\n      (0, _defineProperty2.default)(target, key, source[key]);\n    }) : _Object$getOwnPropertyDescriptors ? _Object$defineProperties(target, _Object$getOwnPropertyDescriptors(source)) : _forEachInstanceProperty(_context4 = ownKeys(Object(source))).call(_context4, function (key) {\n      _Object$defineProperty(target, key, _Object$getOwnPropertyDescriptor(source, key));\n    });\n  }\n  return target;\n}\nfunction _createForOfIteratorHelper(o, allowArrayLike) {\n  var it = typeof _Symbol !== \"undefined\" && _getIteratorMethod(o) || o[\"@@iterator\"];\n  if (!it) {\n    if (_Array$isArray2(o) || (it = _unsupportedIterableToArray(o)) || allowArrayLike && o && typeof o.length === \"number\") {\n      if (it) o = it;\n      var i = 0;\n      var F = function () {};\n      return {\n        s: F,\n        n: function () {\n          if (i >= o.length) return {\n            done: true\n          };\n          return {\n            done: false,\n            value: o[i++]\n          };\n        },\n        e: function (_e) {\n          throw _e;\n        },\n        f: F\n      };\n    }\n    throw new TypeError(\"Invalid attempt to iterate non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\");\n  }\n  var normalCompletion = true,\n    didErr = false,\n    err;\n  return {\n    s: function () {\n      it = it.call(o);\n    },\n    n: function () {\n      var step = it.next();\n      normalCompletion = step.done;\n      return step;\n    },\n    e: function (_e2) {\n      didErr = true;\n      err = _e2;\n    },\n    f: function () {\n      try {\n        if (!normalCompletion && it.return != null) it.return();\n      } finally {\n        if (didErr) throw err;\n      }\n    }\n  };\n}\nfunction _unsupportedIterableToArray(o, minLen) {\n  var _context2;\n  if (!o) return;\n  if (typeof o === \"string\") return _arrayLikeToArray(o, minLen);\n  var n = _sliceInstanceProperty2(_context2 = Object.prototype.toString.call(o)).call(_context2, 8, -1);\n  if (n === \"Object\" && o.constructor) n = o.constructor.name;\n  if (n === \"Map\" || n === \"Set\") return _Array$from(o);\n  if (n === \"Arguments\" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen);\n}\nfunction _arrayLikeToArray(arr, len) {\n  if (len == null || len > arr.length) len = arr.length;\n  for (var i = 0, arr2 = new Array(len); i < len; i++) arr2[i] = arr[i];\n  return arr2;\n} /**\n   * @flow\n   */\n/*:: type Entity = Entity;*/\n/*:: type UsersMap = { [userId: string]: boolean | any };*/\n/*:: export type PermissionsMap = { [permission: string]: UsersMap };*/\nvar PUBLIC_KEY = '*';\nvar VALID_PERMISSIONS /*: Map<string, UsersMap>*/ = new _map.default(\n  /*:: <string, UsersMap>*/\n);\nVALID_PERMISSIONS.set('get', {});\nVALID_PERMISSIONS.set('find', {});\nVALID_PERMISSIONS.set('count', {});\nVALID_PERMISSIONS.set('create', {});\nVALID_PERMISSIONS.set('update', {});\nVALID_PERMISSIONS.set('delete', {});\nVALID_PERMISSIONS.set('addField', {});\nvar VALID_PERMISSIONS_EXTENDED /*: Map<string, UsersMap>*/ = new _map.default(\n  /*:: <string, UsersMap>*/\n);\nVALID_PERMISSIONS_EXTENDED.set('protectedFields', {});\n\n/**\n * Creates a new CLP.\n * If no argument is given, the CLP has no permissions for anyone.\n * If the argument is a Parse.User or Parse.Role, the CLP will have read and write\n *   permission for only that user or role.\n * If the argument is any other JSON object, that object will be interpretted\n *   as a serialized CLP created with toJSON().\n *\n * <p>A CLP, or Class Level Permissions can be added to any\n * <code>Parse.Schema</code> to restrict access to only a subset of users\n * of your application.</p>\n *\n * <p>\n * For get/count/find/create/update/delete/addField using the following functions:\n *\n * Entity is type Parse.User or Parse.Role or string\n * Role is type Parse.Role or Name of Parse.Role\n *\n * getGetRequiresAuthentication()\n * setGetRequiresAuthentication(allowed: boolean)\n * getGetPointerFields()\n * setGetPointerFields(pointerFields: string[])\n * getGetAccess(entity: Entity)\n * setGetAccess(entity: Entity, allowed: boolean)\n * getPublicGetAccess()\n * setPublicGetAccess(allowed: boolean)\n * getRoleGetAccess(role: Role)\n * setRoleGetAccess(role: Role, allowed: boolean)\n * getFindRequiresAuthentication()\n * setFindRequiresAuthentication(allowed: boolean)\n * getFindPointerFields()\n * setFindPointerFields(pointerFields: string[])\n * getFindAccess(entity: Entity)\n * setFindAccess(entity: Entity, allowed: boolean)\n * getPublicFindAccess()\n * setPublicFindAccess(allowed: boolean)\n * getRoleFindAccess(role: Role)\n * setRoleFindAccess(role: Role, allowed: boolean)\n * getCountRequiresAuthentication()\n * setCountRequiresAuthentication(allowed: boolean)\n * getCountPointerFields()\n * setCountPointerFields(pointerFields: string[])\n * getCountAccess(entity: Entity)\n * setCountAccess(entity: Entity, allowed: boolean)\n * getPublicCountAccess()\n * setPublicCountAccess(allowed: boolean)\n * getRoleCountAccess(role: Role)\n * setRoleCountAccess(role: Role, allowed: boolean)\n * getCreateRequiresAuthentication()\n * setCreateRequiresAuthentication(allowed: boolean)\n * getCreatePointerFields()\n * setCreatePointerFields(pointerFields: string[])\n * getCreateAccess(entity: Entity)\n * setCreateAccess(entity: Entity, allowed: boolean)\n * getPublicCreateAccess()\n * setPublicCreateAccess(allowed: Boolean)\n * getRoleCreateAccess(role: Role)\n * setRoleCreateAccess(role: Role, allowed: boolean)\n * getUpdateRequiresAuthentication()\n * setUpdateRequiresAuthentication(allowed: boolean)\n * getUpdatePointerFields()\n * setUpdatePointerFields(pointerFields: string[])\n * getUpdateAccess(entity: Entity)\n * setUpdateAccess(entity: Entity, allowed: boolean)\n * getPublicUpdateAccess()\n * setPublicUpdateAccess(allowed: boolean)\n * getRoleUpdateAccess(role: Role)\n * setRoleUpdateAccess(role: Role, allowed: boolean)\n * getDeleteRequiresAuthentication()\n * setDeleteRequiresAuthentication(allowed: boolean)\n * getDeletePointerFields()\n * setDeletePointerFields(pointerFields: string[])\n * getDeleteAccess(entity: Entity)\n * setDeleteAccess(entity: Entity, allowed: boolean)\n * getPublicDeleteAccess()\n * setPublicDeleteAccess(allowed: boolean)\n * getRoleDeleteAccess(role: Role)\n * setRoleDeleteAccess(role: Role, allowed: boolean)\n * getAddFieldRequiresAuthentication()\n * setAddFieldRequiresAuthentication(allowed: boolean)\n * getAddFieldPointerFields()\n * setAddFieldPointerFields(pointerFields: string[])\n * getAddFieldAccess(entity: Entity)\n * setAddFieldAccess(entity: Entity, allowed: boolean)\n * getPublicAddFieldAccess()\n * setPublicAddFieldAccess(allowed: boolean)\n * getRoleAddFieldAccess(role: Role)\n * setRoleAddFieldAccess(role: Role, allowed: boolean)\n * </p>\n *\n * @alias Parse.CLP\n */\nvar ParseCLP = /*#__PURE__*/function () {\n  /**\n   * @param {(Parse.User | Parse.Role | object)} userId The user to initialize the CLP for\n   */\n  function ParseCLP(userId /*: ParseUser | ParseRole | PermissionsMap*/) {\n    var _this = this;\n    (0, _classCallCheck2.default)(this, ParseCLP);\n    (0, _defineProperty2.default)(this, \"permissionsMap\", void 0);\n    this.permissionsMap = {};\n    // Initialize permissions Map with default permissions\n    var _iterator = _createForOfIteratorHelper((0, _entries.default)(VALID_PERMISSIONS).call(VALID_PERMISSIONS)),\n      _step;\n    try {\n      var _loop = function _loop() {\n        var _step$value = (0, _slicedToArray2.default)(_step.value, 2),\n          operation = _step$value[0],\n          group = _step$value[1];\n        _this.permissionsMap[operation] = (0, _assign.default)({}, group);\n        var action = operation.charAt(0).toUpperCase() + (0, _slice.default)(operation).call(operation, 1);\n        _this[\"get\".concat(action, \"RequiresAuthentication\")] = function () {\n          return this._getAccess(operation, 'requiresAuthentication');\n        };\n        _this[\"set\".concat(action, \"RequiresAuthentication\")] = function (allowed) {\n          this._setAccess(operation, 'requiresAuthentication', allowed);\n        };\n        _this[\"get\".concat(action, \"PointerFields\")] = function () {\n          return this._getAccess(operation, 'pointerFields', false);\n        };\n        _this[\"set\".concat(action, \"PointerFields\")] = function (pointerFields) {\n          this._setArrayAccess(operation, 'pointerFields', pointerFields);\n        };\n        _this[\"get\".concat(action, \"Access\")] = function (entity) {\n          return this._getAccess(operation, entity);\n        };\n        _this[\"set\".concat(action, \"Access\")] = function (entity, allowed) {\n          this._setAccess(operation, entity, allowed);\n        };\n        _this[\"getPublic\".concat(action, \"Access\")] = function () {\n          return this[\"get\".concat(action, \"Access\")](PUBLIC_KEY);\n        };\n        _this[\"setPublic\".concat(action, \"Access\")] = function (allowed) {\n          this[\"set\".concat(action, \"Access\")](PUBLIC_KEY, allowed);\n        };\n        _this[\"getRole\".concat(action, \"Access\")] = function (role) {\n          return this[\"get\".concat(action, \"Access\")](this._getRoleName(role));\n        };\n        _this[\"setRole\".concat(action, \"Access\")] = function (role, allowed) {\n          this[\"set\".concat(action, \"Access\")](this._getRoleName(role), allowed);\n        };\n      };\n      for (_iterator.s(); !(_step = _iterator.n()).done;) {\n        _loop();\n      }\n      // Initialize permissions Map with default extended permissions\n    } catch (err) {\n      _iterator.e(err);\n    } finally {\n      _iterator.f();\n    }\n    var _iterator2 = _createForOfIteratorHelper((0, _entries.default)(VALID_PERMISSIONS_EXTENDED).call(VALID_PERMISSIONS_EXTENDED)),\n      _step2;\n    try {\n      for (_iterator2.s(); !(_step2 = _iterator2.n()).done;) {\n        var _step2$value = (0, _slicedToArray2.default)(_step2.value, 2),\n          operation = _step2$value[0],\n          group = _step2$value[1];\n        this.permissionsMap[operation] = (0, _assign.default)({}, group);\n      }\n    } catch (err) {\n      _iterator2.e(err);\n    } finally {\n      _iterator2.f();\n    }\n    if (userId && (0, _typeof2.default)(userId) === 'object') {\n      if (userId instanceof _ParseUser.default) {\n        this.setReadAccess(userId, true);\n        this.setWriteAccess(userId, true);\n      } else if (userId instanceof _ParseRole.default) {\n        this.setRoleReadAccess(userId, true);\n        this.setRoleWriteAccess(userId, true);\n      } else {\n        for (var _permission in userId) {\n          var _context;\n          var users = userId[_permission];\n          var isValidPermission = !!VALID_PERMISSIONS.get(_permission);\n          var isValidPermissionExtended = !!VALID_PERMISSIONS_EXTENDED.get(_permission);\n          var isValidGroupPermission = (0, _includes.default)(_context = ['readUserFields', 'writeUserFields']).call(_context, _permission);\n          if (typeof _permission !== 'string' || !(isValidPermission || isValidPermissionExtended || isValidGroupPermission)) {\n            throw new TypeError('Tried to create an CLP with an invalid permission type.');\n          }\n          if (isValidGroupPermission) {\n            if ((0, _every.default)(users).call(users, function (pointer) {\n              return typeof pointer === 'string';\n            })) {\n              this.permissionsMap[_permission] = users;\n              continue;\n            } else {\n              throw new TypeError('Tried to create an CLP with an invalid permission value.');\n            }\n          }\n          for (var user in users) {\n            var allowed = users[user];\n            if (typeof allowed !== 'boolean' && !isValidPermissionExtended && user !== 'pointerFields') {\n              throw new TypeError('Tried to create an CLP with an invalid permission value.');\n            }\n            this.permissionsMap[_permission][user] = allowed;\n          }\n        }\n      }\n    } else if (typeof userId === 'function') {\n      throw new TypeError('ParseCLP constructed with a function. Did you forget ()?');\n    }\n  }\n\n  /**\n   * Returns a JSON-encoded version of the CLP.\n   *\n   * @returns {object}\n   */\n  (0, _createClass2.default)(ParseCLP, [{\n    key: \"toJSON\",\n    value: function toJSON() /*: PermissionsMap*/{\n      return _objectSpread({}, this.permissionsMap);\n    }\n\n    /**\n     * Returns whether this CLP is equal to another object\n     *\n     * @param other The other object to compare to\n     * @returns {boolean}\n     */\n  }, {\n    key: \"equals\",\n    value: function equals(other /*: ParseCLP*/) /*: boolean*/{\n      if (!(other instanceof ParseCLP)) {\n        return false;\n      }\n      var permissions = (0, _keys.default)(this.permissionsMap);\n      var otherPermissions = (0, _keys.default)(other.permissionsMap);\n      if (permissions.length !== otherPermissions.length) {\n        return false;\n      }\n      for (var _permission2 in this.permissionsMap) {\n        if (!other.permissionsMap[_permission2]) {\n          return false;\n        }\n        var users = (0, _keys.default)(this.permissionsMap[_permission2]);\n        var otherUsers = (0, _keys.default)(other.permissionsMap[_permission2]);\n        if (users.length !== otherUsers.length) {\n          return false;\n        }\n        for (var user in this.permissionsMap[_permission2]) {\n          if (!other.permissionsMap[_permission2][user]) {\n            return false;\n          }\n          if (this.permissionsMap[_permission2][user] !== other.permissionsMap[_permission2][user]) {\n            return false;\n          }\n        }\n      }\n      return true;\n    }\n  }, {\n    key: \"_getRoleName\",\n    value: function _getRoleName(role /*: ParseRole | string*/) /*: string*/{\n      var name = role;\n      if (role instanceof _ParseRole.default) {\n        // Normalize to the String name\n        name = role.getName();\n      }\n      if (typeof name !== 'string') {\n        throw new TypeError('role must be a Parse.Role or a String');\n      }\n      return \"role:\".concat(name);\n    }\n  }, {\n    key: \"_parseEntity\",\n    value: function _parseEntity(entity /*: Entity*/) {\n      var userId = entity;\n      if (userId instanceof _ParseUser.default) {\n        userId = userId.id;\n        if (!userId) {\n          throw new Error('Cannot get access for a Parse.User without an id.');\n        }\n      } else if (userId instanceof _ParseRole.default) {\n        userId = this._getRoleName(userId);\n      }\n      if (typeof userId !== 'string') {\n        throw new TypeError('userId must be a string.');\n      }\n      return userId;\n    }\n  }, {\n    key: \"_setAccess\",\n    value: function _setAccess(permission /*: string*/, userId /*: Entity*/, allowed /*: boolean*/) {\n      userId = this._parseEntity(userId);\n      if (typeof allowed !== 'boolean') {\n        throw new TypeError('allowed must be either true or false.');\n      }\n      var permissions = this.permissionsMap[permission][userId];\n      if (!permissions) {\n        if (!allowed) {\n          // The user already doesn't have this permission, so no action is needed\n          return;\n        } else {\n          this.permissionsMap[permission][userId] = {};\n        }\n      }\n      if (allowed) {\n        this.permissionsMap[permission][userId] = true;\n      } else {\n        delete this.permissionsMap[permission][userId];\n      }\n    }\n  }, {\n    key: \"_getAccess\",\n    value: function _getAccess(permission /*: string*/, userId /*: Entity*/) /*: boolean | string[]*/{\n      var returnBoolean = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : true;\n      userId = this._parseEntity(userId);\n      var permissions = this.permissionsMap[permission][userId];\n      if (returnBoolean) {\n        if (!permissions) {\n          return false;\n        }\n        return !!this.permissionsMap[permission][userId];\n      }\n      return permissions;\n    }\n  }, {\n    key: \"_setArrayAccess\",\n    value: function _setArrayAccess(permission /*: string*/, userId /*: Entity*/, fields /*: string*/) {\n      userId = this._parseEntity(userId);\n      var permissions = this.permissionsMap[permission][userId];\n      if (!permissions) {\n        this.permissionsMap[permission][userId] = [];\n      }\n      if (!fields || (0, _isArray.default)(fields) && fields.length === 0) {\n        delete this.permissionsMap[permission][userId];\n      } else if ((0, _isArray.default)(fields) && (0, _every.default)(fields).call(fields, function (field) {\n        return typeof field === 'string';\n      })) {\n        this.permissionsMap[permission][userId] = fields;\n      } else {\n        throw new TypeError('fields must be an array of strings or undefined.');\n      }\n    }\n  }, {\n    key: \"_setGroupPointerPermission\",\n    value: function _setGroupPointerPermission(operation /*: string*/, pointerFields /*: string[]*/) {\n      var fields = this.permissionsMap[operation];\n      if (!fields) {\n        this.permissionsMap[operation] = [];\n      }\n      if (!pointerFields || (0, _isArray.default)(pointerFields) && pointerFields.length === 0) {\n        delete this.permissionsMap[operation];\n      } else if ((0, _isArray.default)(pointerFields) && (0, _every.default)(pointerFields).call(pointerFields, function (field) {\n        return typeof field === 'string';\n      })) {\n        this.permissionsMap[operation] = pointerFields;\n      } else {\n        throw new TypeError(\"\".concat(operation, \".pointerFields must be an array of strings or undefined.\"));\n      }\n    }\n  }, {\n    key: \"_getGroupPointerPermissions\",\n    value: function _getGroupPointerPermissions(operation /*: string*/) /*: string[]*/{\n      return this.permissionsMap[operation];\n    }\n\n    /**\n     * Sets user pointer fields to allow permission for get/count/find operations.\n     *\n     * @param {string[]} pointerFields User pointer fields\n     */\n  }, {\n    key: \"setReadUserFields\",\n    value: function setReadUserFields(pointerFields /*: string[]*/) {\n      this._setGroupPointerPermission('readUserFields', pointerFields);\n    }\n\n    /**\n     * @returns {string[]} User pointer fields\n     */\n  }, {\n    key: \"getReadUserFields\",\n    value: function getReadUserFields() /*: string[]*/{\n      return this._getGroupPointerPermissions('readUserFields');\n    }\n\n    /**\n     * Sets user pointer fields to allow permission for create/delete/update/addField operations\n     *\n     * @param {string[]} pointerFields User pointer fields\n     */\n  }, {\n    key: \"setWriteUserFields\",\n    value: function setWriteUserFields(pointerFields /*: string[]*/) {\n      this._setGroupPointerPermission('writeUserFields', pointerFields);\n    }\n\n    /**\n     * @returns {string[]} User pointer fields\n     */\n  }, {\n    key: \"getWriteUserFields\",\n    value: function getWriteUserFields() /*: string[]*/{\n      return this._getGroupPointerPermissions('writeUserFields');\n    }\n\n    /**\n     * Sets whether the given user is allowed to retrieve fields from this class.\n     *\n     * @param userId An instance of Parse.User or its objectId.\n     * @param {string[]} fields fields to be protected\n     */\n  }, {\n    key: \"setProtectedFields\",\n    value: function setProtectedFields(userId /*: Entity*/, fields /*: string[]*/) {\n      this._setArrayAccess('protectedFields', userId, fields);\n    }\n\n    /**\n     * Returns array of fields are accessable to this user.\n     *\n     * @param userId An instance of Parse.User or its objectId, or a Parse.Role.\n     * @returns {string[]}\n     */\n  }, {\n    key: \"getProtectedFields\",\n    value: function getProtectedFields(userId /*: Entity*/) /*: string[]*/{\n      return this._getAccess('protectedFields', userId, false);\n    }\n\n    /**\n     * Sets whether the given user is allowed to read from this class.\n     *\n     * @param userId An instance of Parse.User or its objectId.\n     * @param {boolean} allowed whether that user should have read access.\n     */\n  }, {\n    key: \"setReadAccess\",\n    value: function setReadAccess(userId /*: Entity*/, allowed /*: boolean*/) {\n      this._setAccess('find', userId, allowed);\n      this._setAccess('get', userId, allowed);\n      this._setAccess('count', userId, allowed);\n    }\n\n    /**\n     * Get whether the given user id is *explicitly* allowed to read from this class.\n     * Even if this returns false, the user may still be able to access it if\n     * getPublicReadAccess returns true or a role that the user belongs to has\n     * write access.\n     *\n     * @param userId An instance of Parse.User or its objectId, or a Parse.Role.\n     * @returns {boolean}\n     */\n  }, {\n    key: \"getReadAccess\",\n    value: function getReadAccess(userId /*: Entity*/) /*: boolean*/{\n      return this._getAccess('find', userId) && this._getAccess('get', userId) && this._getAccess('count', userId);\n    }\n\n    /**\n     * Sets whether the given user id is allowed to write to this class.\n     *\n     * @param userId An instance of Parse.User or its objectId, or a Parse.Role..\n     * @param {boolean} allowed Whether that user should have write access.\n     */\n  }, {\n    key: \"setWriteAccess\",\n    value: function setWriteAccess(userId /*: Entity*/, allowed /*: boolean*/) {\n      this._setAccess('create', userId, allowed);\n      this._setAccess('update', userId, allowed);\n      this._setAccess('delete', userId, allowed);\n      this._setAccess('addField', userId, allowed);\n    }\n\n    /**\n     * Gets whether the given user id is *explicitly* allowed to write to this class.\n     * Even if this returns false, the user may still be able to write it if\n     * getPublicWriteAccess returns true or a role that the user belongs to has\n     * write access.\n     *\n     * @param userId An instance of Parse.User or its objectId, or a Parse.Role.\n     * @returns {boolean}\n     */\n  }, {\n    key: \"getWriteAccess\",\n    value: function getWriteAccess(userId /*: Entity*/) /*: boolean*/{\n      return this._getAccess('create', userId) && this._getAccess('update', userId) && this._getAccess('delete', userId) && this._getAccess('addField', userId);\n    }\n\n    /**\n     * Sets whether the public is allowed to read from this class.\n     *\n     * @param {boolean} allowed\n     */\n  }, {\n    key: \"setPublicReadAccess\",\n    value: function setPublicReadAccess(allowed /*: boolean*/) {\n      this.setReadAccess(PUBLIC_KEY, allowed);\n    }\n\n    /**\n     * Gets whether the public is allowed to read from this class.\n     *\n     * @returns {boolean}\n     */\n  }, {\n    key: \"getPublicReadAccess\",\n    value: function getPublicReadAccess() /*: boolean*/{\n      return this.getReadAccess(PUBLIC_KEY);\n    }\n\n    /**\n     * Sets whether the public is allowed to write to this class.\n     *\n     * @param {boolean} allowed\n     */\n  }, {\n    key: \"setPublicWriteAccess\",\n    value: function setPublicWriteAccess(allowed /*: boolean*/) {\n      this.setWriteAccess(PUBLIC_KEY, allowed);\n    }\n\n    /**\n     * Gets whether the public is allowed to write to this class.\n     *\n     * @returns {boolean}\n     */\n  }, {\n    key: \"getPublicWriteAccess\",\n    value: function getPublicWriteAccess() /*: boolean*/{\n      return this.getWriteAccess(PUBLIC_KEY);\n    }\n\n    /**\n     * Sets whether the public is allowed to protect fields in this class.\n     *\n     * @param {string[]} fields\n     */\n  }, {\n    key: \"setPublicProtectedFields\",\n    value: function setPublicProtectedFields(fields /*: string[]*/) {\n      this.setProtectedFields(PUBLIC_KEY, fields);\n    }\n\n    /**\n     * Gets whether the public is allowed to read fields from this class.\n     *\n     * @returns {string[]}\n     */\n  }, {\n    key: \"getPublicProtectedFields\",\n    value: function getPublicProtectedFields() /*: string[]*/{\n      return this.getProtectedFields(PUBLIC_KEY);\n    }\n\n    /**\n     * Gets whether users belonging to the given role are allowed\n     * to read from this class. Even if this returns false, the role may\n     * still be able to write it if a parent role has read access.\n     *\n     * @param role The name of the role, or a Parse.Role object.\n     * @returns {boolean} true if the role has read access. false otherwise.\n     * @throws {TypeError} If role is neither a Parse.Role nor a String.\n     */\n  }, {\n    key: \"getRoleReadAccess\",\n    value: function getRoleReadAccess(role /*: ParseRole | string*/) /*: boolean*/{\n      return this.getReadAccess(this._getRoleName(role));\n    }\n\n    /**\n     * Gets whether users belonging to the given role are allowed\n     * to write to this user. Even if this returns false, the role may\n     * still be able to write it if a parent role has write access.\n     *\n     * @param role The name of the role, or a Parse.Role object.\n     * @returns {boolean} true if the role has write access. false otherwise.\n     * @throws {TypeError} If role is neither a Parse.Role nor a String.\n     */\n  }, {\n    key: \"getRoleWriteAccess\",\n    value: function getRoleWriteAccess(role /*: ParseRole | string*/) /*: boolean*/{\n      return this.getWriteAccess(this._getRoleName(role));\n    }\n\n    /**\n     * Sets whether users belonging to the given role are allowed\n     * to read from this class.\n     *\n     * @param role The name of the role, or a Parse.Role object.\n     * @param {boolean} allowed Whether the given role can read this object.\n     * @throws {TypeError} If role is neither a Parse.Role nor a String.\n     */\n  }, {\n    key: \"setRoleReadAccess\",\n    value: function setRoleReadAccess(role /*: ParseRole | string*/, allowed /*: boolean*/) {\n      this.setReadAccess(this._getRoleName(role), allowed);\n    }\n\n    /**\n     * Sets whether users belonging to the given role are allowed\n     * to write to this class.\n     *\n     * @param role The name of the role, or a Parse.Role object.\n     * @param {boolean} allowed Whether the given role can write this object.\n     * @throws {TypeError} If role is neither a Parse.Role nor a String.\n     */\n  }, {\n    key: \"setRoleWriteAccess\",\n    value: function setRoleWriteAccess(role /*: ParseRole | string*/, allowed /*: boolean*/) {\n      this.setWriteAccess(this._getRoleName(role), allowed);\n    }\n\n    /**\n     * Gets whether users belonging to the given role are allowed\n     * to count to this user. Even if this returns false, the role may\n     * still be able to count it if a parent role has count access.\n     *\n     * @param role The name of the role, or a Parse.Role object.\n     * @returns {string[]}\n     * @throws {TypeError} If role is neither a Parse.Role nor a String.\n     */\n  }, {\n    key: \"getRoleProtectedFields\",\n    value: function getRoleProtectedFields(role /*: ParseRole | string*/) /*: string[]*/{\n      return this.getProtectedFields(this._getRoleName(role));\n    }\n\n    /**\n     * Sets whether users belonging to the given role are allowed\n     * to set access field in this class.\n     *\n     * @param role The name of the role, or a Parse.Role object.\n     * @param {string[]} fields Fields to be protected by Role.\n     * @throws {TypeError} If role is neither a Parse.Role nor a String.\n     */\n  }, {\n    key: \"setRoleProtectedFields\",\n    value: function setRoleProtectedFields(role /*: ParseRole | string*/, fields /*: string[]*/) {\n      this.setProtectedFields(this._getRoleName(role), fields);\n    }\n  }]);\n  return ParseCLP;\n}();\nvar _default = ParseCLP;\nexports.default = _default;"],"mappings":"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E,CAAC,CAAC,CAAC;;AAErD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,IAAIE,QAAQ,GAAG,aAAa,YAAY;EACtC;AACF;AACA;EACE,SAASA,QAAQA,CAACC,MAAM,CAAC,8CAA8C;IACrE,IAAIC,KAAK,GAAG,IAAI;IAChB,CAAC,CAAC,EAAEvE,gBAAgB,CAACH,OAAO,EAAE,IAAI,EAAEwE,QAAQ,CAAC;IAC7C,CAAC,CAAC,EAAEnE,gBAAgB,CAACL,OAAO,EAAE,IAAI,EAAE,gBAAgB,EAAE,KAAK,CAAC,CAAC;IAC7D,IAAI,CAAC2E,cAAc,GAAG,CAAC,CAAC;IACxB;IACA,IAAIC,SAAS,GAAGxC,0BAA0B,CAAC,CAAC,CAAC,EAAE3B,QAAQ,CAACT,OAAO,EAAEqE,iBAAiB,CAAC,CAAChD,IAAI,CAACgD,iBAAiB,CAAC,CAAC;MAC1GQ,KAAK;IACP,IAAI;MACF,IAAIC,KAAK,GAAG,SAASA,KAAKA,CAAA,EAAG;QAC3B,IAAIC,WAAW,GAAG,CAAC,CAAC,EAAE9E,eAAe,CAACD,OAAO,EAAE6E,KAAK,CAAC9E,KAAK,EAAE,CAAC,CAAC;UAC5DiF,SAAS,GAAGD,WAAW,CAAC,CAAC,CAAC;UAC1BE,KAAK,GAAGF,WAAW,CAAC,CAAC,CAAC;QACxBL,KAAK,CAACC,cAAc,CAACK,SAAS,CAAC,GAAG,CAAC,CAAC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"},"metadata":{},"sourceType":"script","externalDependencies":[]}