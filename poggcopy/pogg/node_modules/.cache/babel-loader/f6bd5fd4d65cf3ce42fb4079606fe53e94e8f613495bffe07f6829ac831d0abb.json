{"ast":null,"code":"\"use strict\";\n\nvar _Object$defineProperty = require(\"@babel/runtime-corejs3/core-js-stable/object/define-property\");\nvar _interopRequireDefault = require(\"@babel/runtime-corejs3/helpers/interopRequireDefault\");\n_Object$defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.default = void 0;\nvar _keys = _interopRequireDefault(require(\"@babel/runtime-corejs3/core-js-stable/object/keys\"));\nvar _typeof2 = _interopRequireDefault(require(\"@babel/runtime-corejs3/helpers/typeof\"));\nvar _classCallCheck2 = _interopRequireDefault(require(\"@babel/runtime-corejs3/helpers/classCallCheck\"));\nvar _createClass2 = _interopRequireDefault(require(\"@babel/runtime-corejs3/helpers/createClass\"));\nvar _defineProperty2 = _interopRequireDefault(require(\"@babel/runtime-corejs3/helpers/defineProperty\"));\nvar _ParseRole = _interopRequireDefault(require(\"./ParseRole\"));\nvar _ParseUser = _interopRequireDefault(require(\"./ParseUser\"));\n/**\n * @flow\n */\n/*:: type PermissionsMap = { [permission: string]: boolean };*/\n/*:: type ByIdMap = { [userId: string]: PermissionsMap };*/\nvar PUBLIC_KEY = '*';\n\n/**\n * Creates a new ACL.\n * If no argument is given, the ACL has no permissions for anyone.\n * If the argument is a Parse.User, the ACL will have read and write\n *   permission for only that user.\n * If the argument is any other JSON object, that object will be interpretted\n *   as a serialized ACL created with toJSON().\n *\n * <p>An ACL, or Access Control List can be added to any\n * <code>Parse.Object</code> to restrict access to only a subset of users\n * of your application.</p>\n *\n * @alias Parse.ACL\n */\nvar ParseACL = /*#__PURE__*/function () {\n  /**\n   * @param {(Parse.User | object)} arg1 The user to initialize the ACL for\n   */\n  function ParseACL(arg1 /*: ParseUser | ByIdMap*/) {\n    (0, _classCallCheck2.default)(this, ParseACL);\n    (0, _defineProperty2.default)(this, \"permissionsById\", void 0);\n    this.permissionsById = {};\n    if (arg1 && (0, _typeof2.default)(arg1) === 'object') {\n      if (arg1 instanceof _ParseUser.default) {\n        this.setReadAccess(arg1, true);\n        this.setWriteAccess(arg1, true);\n      } else {\n        for (var _userId in arg1) {\n          var accessList = arg1[_userId];\n          this.permissionsById[_userId] = {};\n          for (var _permission in accessList) {\n            var allowed = accessList[_permission];\n            if (_permission !== 'read' && _permission !== 'write') {\n              throw new TypeError('Tried to create an ACL with an invalid permission type.');\n            }\n            if (typeof allowed !== 'boolean') {\n              throw new TypeError('Tried to create an ACL with an invalid permission value.');\n            }\n            this.permissionsById[_userId][_permission] = allowed;\n          }\n        }\n      }\n    } else if (typeof arg1 === 'function') {\n      throw new TypeError('ParseACL constructed with a function. Did you forget ()?');\n    }\n  }\n\n  /**\n   * Returns a JSON-encoded version of the ACL.\n   *\n   * @returns {object}\n   */\n  (0, _createClass2.default)(ParseACL, [{\n    key: \"toJSON\",\n    value: function () /*: ByIdMap*/{\n      var permissions = {};\n      for (var p in this.permissionsById) {\n        permissions[p] = this.permissionsById[p];\n      }\n      return permissions;\n    }\n\n    /**\n     * Returns whether this ACL is equal to another object\n     *\n     * @param {ParseACL} other The other object's ACL to compare to\n     * @returns {boolean}\n     */\n  }, {\n    key: \"equals\",\n    value: function (other /*: ParseACL*/) /*: boolean*/{\n      if (!(other instanceof ParseACL)) {\n        return false;\n      }\n      var users = (0, _keys.default)(this.permissionsById);\n      var otherUsers = (0, _keys.default)(other.permissionsById);\n      if (users.length !== otherUsers.length) {\n        return false;\n      }\n      for (var u in this.permissionsById) {\n        if (!other.permissionsById[u]) {\n          return false;\n        }\n        if (this.permissionsById[u].read !== other.permissionsById[u].read) {\n          return false;\n        }\n        if (this.permissionsById[u].write !== other.permissionsById[u].write) {\n          return false;\n        }\n      }\n      return true;\n    }\n  }, {\n    key: \"_setAccess\",\n    value: function (accessType /*: string*/, userId /*: ParseUser | ParseRole | string*/, allowed /*: boolean*/) {\n      if (userId instanceof _ParseUser.default) {\n        userId = userId.id;\n      } else if (userId instanceof _ParseRole.default) {\n        var name = userId.getName();\n        if (!name) {\n          throw new TypeError('Role must have a name');\n        }\n        userId = 'role:' + name;\n      }\n      if (typeof userId !== 'string') {\n        throw new TypeError('userId must be a string.');\n      }\n      if (typeof allowed !== 'boolean') {\n        throw new TypeError('allowed must be either true or false.');\n      }\n      var permissions = this.permissionsById[userId];\n      if (!permissions) {\n        if (!allowed) {\n          // The user already doesn't have this permission, so no action is needed\n          return;\n        } else {\n          permissions = {};\n          this.permissionsById[userId] = permissions;\n        }\n      }\n      if (allowed) {\n        this.permissionsById[userId][accessType] = true;\n      } else {\n        delete permissions[accessType];\n        if ((0, _keys.default)(permissions).length === 0) {\n          delete this.permissionsById[userId];\n        }\n      }\n    }\n  }, {\n    key: \"_getAccess\",\n    value: function (accessType /*: string*/, userId /*: ParseUser | ParseRole | string*/) /*: boolean*/{\n      if (userId instanceof _ParseUser.default) {\n        userId = userId.id;\n        if (!userId) {\n          throw new Error('Cannot get access for a ParseUser without an ID');\n        }\n      } else if (userId instanceof _ParseRole.default) {\n        var name = userId.getName();\n        if (!name) {\n          throw new TypeError('Role must have a name');\n        }\n        userId = 'role:' + name;\n      }\n      var permissions = this.permissionsById[userId];\n      if (!permissions) {\n        return false;\n      }\n      return !!permissions[accessType];\n    }\n\n    /**\n     * Sets whether the given user is allowed to read this object.\n     *\n     * @param userId An instance of Parse.User or its objectId.\n     * @param {boolean} allowed Whether that user should have read access.\n     */\n  }, {\n    key: \"setReadAccess\",\n    value: function (userId /*: ParseUser | ParseRole | string*/, allowed /*: boolean*/) {\n      this._setAccess('read', userId, allowed);\n    }\n\n    /**\n     * Get whether the given user id is *explicitly* allowed to read this object.\n     * Even if this returns false, the user may still be able to access it if\n     * getPublicReadAccess returns true or a role that the user belongs to has\n     * write access.\n     *\n     * @param userId An instance of Parse.User or its objectId, or a Parse.Role.\n     * @returns {boolean}\n     */\n  }, {\n    key: \"getReadAccess\",\n    value: function (userId /*: ParseUser | ParseRole | string*/) /*: boolean*/{\n      return this._getAccess('read', userId);\n    }\n\n    /**\n     * Sets whether the given user id is allowed to write this object.\n     *\n     * @param userId An instance of Parse.User or its objectId, or a Parse.Role..\n     * @param {boolean} allowed Whether that user should have write access.\n     */\n  }, {\n    key: \"setWriteAccess\",\n    value: function (userId /*: ParseUser | ParseRole | string*/, allowed /*: boolean*/) {\n      this._setAccess('write', userId, allowed);\n    }\n\n    /**\n     * Gets whether the given user id is *explicitly* allowed to write this object.\n     * Even if this returns false, the user may still be able to write it if\n     * getPublicWriteAccess returns true or a role that the user belongs to has\n     * write access.\n     *\n     * @param userId An instance of Parse.User or its objectId, or a Parse.Role.\n     * @returns {boolean}\n     */\n  }, {\n    key: \"getWriteAccess\",\n    value: function (userId /*: ParseUser | ParseRole | string*/) /*: boolean*/{\n      return this._getAccess('write', userId);\n    }\n\n    /**\n     * Sets whether the public is allowed to read this object.\n     *\n     * @param {boolean} allowed\n     */\n  }, {\n    key: \"setPublicReadAccess\",\n    value: function (allowed /*: boolean*/) {\n      this.setReadAccess(PUBLIC_KEY, allowed);\n    }\n\n    /**\n     * Gets whether the public is allowed to read this object.\n     *\n     * @returns {boolean}\n     */\n  }, {\n    key: \"getPublicReadAccess\",\n    value: function () /*: boolean*/{\n      return this.getReadAccess(PUBLIC_KEY);\n    }\n\n    /**\n     * Sets whether the public is allowed to write this object.\n     *\n     * @param {boolean} allowed\n     */\n  }, {\n    key: \"setPublicWriteAccess\",\n    value: function (allowed /*: boolean*/) {\n      this.setWriteAccess(PUBLIC_KEY, allowed);\n    }\n\n    /**\n     * Gets whether the public is allowed to write this object.\n     *\n     * @returns {boolean}\n     */\n  }, {\n    key: \"getPublicWriteAccess\",\n    value: function () /*: boolean*/{\n      return this.getWriteAccess(PUBLIC_KEY);\n    }\n\n    /**\n     * Gets whether users belonging to the given role are allowed\n     * to read this object. Even if this returns false, the role may\n     * still be able to write it if a parent role has read access.\n     *\n     * @param role The name of the role, or a Parse.Role object.\n     * @returns {boolean} true if the role has read access. false otherwise.\n     * @throws {TypeError} If role is neither a Parse.Role nor a String.\n     */\n  }, {\n    key: \"getRoleReadAccess\",\n    value: function (role /*: ParseRole | string*/) /*: boolean*/{\n      if (role instanceof _ParseRole.default) {\n        // Normalize to the String name\n        role = role.getName();\n      }\n      if (typeof role !== 'string') {\n        throw new TypeError('role must be a ParseRole or a String');\n      }\n      return this.getReadAccess('role:' + role);\n    }\n\n    /**\n     * Gets whether users belonging to the given role are allowed\n     * to write this object. Even if this returns false, the role may\n     * still be able to write it if a parent role has write access.\n     *\n     * @param role The name of the role, or a Parse.Role object.\n     * @returns {boolean} true if the role has write access. false otherwise.\n     * @throws {TypeError} If role is neither a Parse.Role nor a String.\n     */\n  }, {\n    key: \"getRoleWriteAccess\",\n    value: function (role /*: ParseRole | string*/) /*: boolean*/{\n      if (role instanceof _ParseRole.default) {\n        // Normalize to the String name\n        role = role.getName();\n      }\n      if (typeof role !== 'string') {\n        throw new TypeError('role must be a ParseRole or a String');\n      }\n      return this.getWriteAccess('role:' + role);\n    }\n\n    /**\n     * Sets whether users belonging to the given role are allowed\n     * to read this object.\n     *\n     * @param role The name of the role, or a Parse.Role object.\n     * @param {boolean} allowed Whether the given role can read this object.\n     * @throws {TypeError} If role is neither a Parse.Role nor a String.\n     */\n  }, {\n    key: \"setRoleReadAccess\",\n    value: function (role /*: ParseRole | string*/, allowed /*: boolean*/) {\n      if (role instanceof _ParseRole.default) {\n        // Normalize to the String name\n        role = role.getName();\n      }\n      if (typeof role !== 'string') {\n        throw new TypeError('role must be a ParseRole or a String');\n      }\n      this.setReadAccess('role:' + role, allowed);\n    }\n\n    /**\n     * Sets whether users belonging to the given role are allowed\n     * to write this object.\n     *\n     * @param role The name of the role, or a Parse.Role object.\n     * @param {boolean} allowed Whether the given role can write this object.\n     * @throws {TypeError} If role is neither a Parse.Role nor a String.\n     */\n  }, {\n    key: \"setRoleWriteAccess\",\n    value: function (role /*: ParseRole | string*/, allowed /*: boolean*/) {\n      if (role instanceof _ParseRole.default) {\n        // Normalize to the String name\n        role = role.getName();\n      }\n      if (typeof role !== 'string') {\n        throw new TypeError('role must be a ParseRole or a String');\n      }\n      this.setWriteAccess('role:' + role, allowed);\n    }\n  }]);\n  return ParseACL;\n}();\nvar _default = ParseACL;\nexports.default = _default;","map":{"version":3,"names":["_Object$defineProperty","require","_interopRequireDefault","exports","value","default","_keys","_typeof2","_classCallCheck2","_createClass2","_defineProperty2","_ParseRole","_ParseUser","PUBLIC_KEY","ParseACL","arg1","permissionsById","setReadAccess","setWriteAccess","_userId","accessList","_permission","allowed","TypeError","key","permissions","p","other","users","otherUsers","length","u","read","write","accessType","userId","id","name","getName","Error","_setAccess","_getAccess","getReadAccess","getWriteAccess","role","_default"],"sources":["/home/mspadafo/compsci/MWD/poggcopy/pogg/node_modules/parse/lib/browser/ParseACL.js"],"sourcesContent":["\"use strict\";\n\nvar _Object$defineProperty = require(\"@babel/runtime-corejs3/core-js-stable/object/define-property\");\nvar _interopRequireDefault = require(\"@babel/runtime-corejs3/helpers/interopRequireDefault\");\n_Object$defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.default = void 0;\nvar _keys = _interopRequireDefault(require(\"@babel/runtime-corejs3/core-js-stable/object/keys\"));\nvar _typeof2 = _interopRequireDefault(require(\"@babel/runtime-corejs3/helpers/typeof\"));\nvar _classCallCheck2 = _interopRequireDefault(require(\"@babel/runtime-corejs3/helpers/classCallCheck\"));\nvar _createClass2 = _interopRequireDefault(require(\"@babel/runtime-corejs3/helpers/createClass\"));\nvar _defineProperty2 = _interopRequireDefault(require(\"@babel/runtime-corejs3/helpers/defineProperty\"));\nvar _ParseRole = _interopRequireDefault(require(\"./ParseRole\"));\nvar _ParseUser = _interopRequireDefault(require(\"./ParseUser\"));\n/**\n * @flow\n */\n/*:: type PermissionsMap = { [permission: string]: boolean };*/\n/*:: type ByIdMap = { [userId: string]: PermissionsMap };*/\nvar PUBLIC_KEY = '*';\n\n/**\n * Creates a new ACL.\n * If no argument is given, the ACL has no permissions for anyone.\n * If the argument is a Parse.User, the ACL will have read and write\n *   permission for only that user.\n * If the argument is any other JSON object, that object will be interpretted\n *   as a serialized ACL created with toJSON().\n *\n * <p>An ACL, or Access Control List can be added to any\n * <code>Parse.Object</code> to restrict access to only a subset of users\n * of your application.</p>\n *\n * @alias Parse.ACL\n */\nvar ParseACL = /*#__PURE__*/function () {\n  /**\n   * @param {(Parse.User | object)} arg1 The user to initialize the ACL for\n   */\n  function ParseACL(arg1 /*: ParseUser | ByIdMap*/) {\n    (0, _classCallCheck2.default)(this, ParseACL);\n    (0, _defineProperty2.default)(this, \"permissionsById\", void 0);\n    this.permissionsById = {};\n    if (arg1 && (0, _typeof2.default)(arg1) === 'object') {\n      if (arg1 instanceof _ParseUser.default) {\n        this.setReadAccess(arg1, true);\n        this.setWriteAccess(arg1, true);\n      } else {\n        for (var _userId in arg1) {\n          var accessList = arg1[_userId];\n          this.permissionsById[_userId] = {};\n          for (var _permission in accessList) {\n            var allowed = accessList[_permission];\n            if (_permission !== 'read' && _permission !== 'write') {\n              throw new TypeError('Tried to create an ACL with an invalid permission type.');\n            }\n            if (typeof allowed !== 'boolean') {\n              throw new TypeError('Tried to create an ACL with an invalid permission value.');\n            }\n            this.permissionsById[_userId][_permission] = allowed;\n          }\n        }\n      }\n    } else if (typeof arg1 === 'function') {\n      throw new TypeError('ParseACL constructed with a function. Did you forget ()?');\n    }\n  }\n\n  /**\n   * Returns a JSON-encoded version of the ACL.\n   *\n   * @returns {object}\n   */\n  (0, _createClass2.default)(ParseACL, [{\n    key: \"toJSON\",\n    value: function () /*: ByIdMap*/{\n      var permissions = {};\n      for (var p in this.permissionsById) {\n        permissions[p] = this.permissionsById[p];\n      }\n      return permissions;\n    }\n\n    /**\n     * Returns whether this ACL is equal to another object\n     *\n     * @param {ParseACL} other The other object's ACL to compare to\n     * @returns {boolean}\n     */\n  }, {\n    key: \"equals\",\n    value: function (other /*: ParseACL*/) /*: boolean*/{\n      if (!(other instanceof ParseACL)) {\n        return false;\n      }\n      var users = (0, _keys.default)(this.permissionsById);\n      var otherUsers = (0, _keys.default)(other.permissionsById);\n      if (users.length !== otherUsers.length) {\n        return false;\n      }\n      for (var u in this.permissionsById) {\n        if (!other.permissionsById[u]) {\n          return false;\n        }\n        if (this.permissionsById[u].read !== other.permissionsById[u].read) {\n          return false;\n        }\n        if (this.permissionsById[u].write !== other.permissionsById[u].write) {\n          return false;\n        }\n      }\n      return true;\n    }\n  }, {\n    key: \"_setAccess\",\n    value: function (accessType /*: string*/, userId /*: ParseUser | ParseRole | string*/, allowed /*: boolean*/) {\n      if (userId instanceof _ParseUser.default) {\n        userId = userId.id;\n      } else if (userId instanceof _ParseRole.default) {\n        var name = userId.getName();\n        if (!name) {\n          throw new TypeError('Role must have a name');\n        }\n        userId = 'role:' + name;\n      }\n      if (typeof userId !== 'string') {\n        throw new TypeError('userId must be a string.');\n      }\n      if (typeof allowed !== 'boolean') {\n        throw new TypeError('allowed must be either true or false.');\n      }\n      var permissions = this.permissionsById[userId];\n      if (!permissions) {\n        if (!allowed) {\n          // The user already doesn't have this permission, so no action is needed\n          return;\n        } else {\n          permissions = {};\n          this.permissionsById[userId] = permissions;\n        }\n      }\n      if (allowed) {\n        this.permissionsById[userId][accessType] = true;\n      } else {\n        delete permissions[accessType];\n        if ((0, _keys.default)(permissions).length === 0) {\n          delete this.permissionsById[userId];\n        }\n      }\n    }\n  }, {\n    key: \"_getAccess\",\n    value: function (accessType /*: string*/, userId /*: ParseUser | ParseRole | string*/) /*: boolean*/{\n      if (userId instanceof _ParseUser.default) {\n        userId = userId.id;\n        if (!userId) {\n          throw new Error('Cannot get access for a ParseUser without an ID');\n        }\n      } else if (userId instanceof _ParseRole.default) {\n        var name = userId.getName();\n        if (!name) {\n          throw new TypeError('Role must have a name');\n        }\n        userId = 'role:' + name;\n      }\n      var permissions = this.permissionsById[userId];\n      if (!permissions) {\n        return false;\n      }\n      return !!permissions[accessType];\n    }\n\n    /**\n     * Sets whether the given user is allowed to read this object.\n     *\n     * @param userId An instance of Parse.User or its objectId.\n     * @param {boolean} allowed Whether that user should have read access.\n     */\n  }, {\n    key: \"setReadAccess\",\n    value: function (userId /*: ParseUser | ParseRole | string*/, allowed /*: boolean*/) {\n      this._setAccess('read', userId, allowed);\n    }\n\n    /**\n     * Get whether the given user id is *explicitly* allowed to read this object.\n     * Even if this returns false, the user may still be able to access it if\n     * getPublicReadAccess returns true or a role that the user belongs to has\n     * write access.\n     *\n     * @param userId An instance of Parse.User or its objectId, or a Parse.Role.\n     * @returns {boolean}\n     */\n  }, {\n    key: \"getReadAccess\",\n    value: function (userId /*: ParseUser | ParseRole | string*/) /*: boolean*/{\n      return this._getAccess('read', userId);\n    }\n\n    /**\n     * Sets whether the given user id is allowed to write this object.\n     *\n     * @param userId An instance of Parse.User or its objectId, or a Parse.Role..\n     * @param {boolean} allowed Whether that user should have write access.\n     */\n  }, {\n    key: \"setWriteAccess\",\n    value: function (userId /*: ParseUser | ParseRole | string*/, allowed /*: boolean*/) {\n      this._setAccess('write', userId, allowed);\n    }\n\n    /**\n     * Gets whether the given user id is *explicitly* allowed to write this object.\n     * Even if this returns false, the user may still be able to write it if\n     * getPublicWriteAccess returns true or a role that the user belongs to has\n     * write access.\n     *\n     * @param userId An instance of Parse.User or its objectId, or a Parse.Role.\n     * @returns {boolean}\n     */\n  }, {\n    key: \"getWriteAccess\",\n    value: function (userId /*: ParseUser | ParseRole | string*/) /*: boolean*/{\n      return this._getAccess('write', userId);\n    }\n\n    /**\n     * Sets whether the public is allowed to read this object.\n     *\n     * @param {boolean} allowed\n     */\n  }, {\n    key: \"setPublicReadAccess\",\n    value: function (allowed /*: boolean*/) {\n      this.setReadAccess(PUBLIC_KEY, allowed);\n    }\n\n    /**\n     * Gets whether the public is allowed to read this object.\n     *\n     * @returns {boolean}\n     */\n  }, {\n    key: \"getPublicReadAccess\",\n    value: function () /*: boolean*/{\n      return this.getReadAccess(PUBLIC_KEY);\n    }\n\n    /**\n     * Sets whether the public is allowed to write this object.\n     *\n     * @param {boolean} allowed\n     */\n  }, {\n    key: \"setPublicWriteAccess\",\n    value: function (allowed /*: boolean*/) {\n      this.setWriteAccess(PUBLIC_KEY, allowed);\n    }\n\n    /**\n     * Gets whether the public is allowed to write this object.\n     *\n     * @returns {boolean}\n     */\n  }, {\n    key: \"getPublicWriteAccess\",\n    value: function () /*: boolean*/{\n      return this.getWriteAccess(PUBLIC_KEY);\n    }\n\n    /**\n     * Gets whether users belonging to the given role are allowed\n     * to read this object. Even if this returns false, the role may\n     * still be able to write it if a parent role has read access.\n     *\n     * @param role The name of the role, or a Parse.Role object.\n     * @returns {boolean} true if the role has read access. false otherwise.\n     * @throws {TypeError} If role is neither a Parse.Role nor a String.\n     */\n  }, {\n    key: \"getRoleReadAccess\",\n    value: function (role /*: ParseRole | string*/) /*: boolean*/{\n      if (role instanceof _ParseRole.default) {\n        // Normalize to the String name\n        role = role.getName();\n      }\n      if (typeof role !== 'string') {\n        throw new TypeError('role must be a ParseRole or a String');\n      }\n      return this.getReadAccess('role:' + role);\n    }\n\n    /**\n     * Gets whether users belonging to the given role are allowed\n     * to write this object. Even if this returns false, the role may\n     * still be able to write it if a parent role has write access.\n     *\n     * @param role The name of the role, or a Parse.Role object.\n     * @returns {boolean} true if the role has write access. false otherwise.\n     * @throws {TypeError} If role is neither a Parse.Role nor a String.\n     */\n  }, {\n    key: \"getRoleWriteAccess\",\n    value: function (role /*: ParseRole | string*/) /*: boolean*/{\n      if (role instanceof _ParseRole.default) {\n        // Normalize to the String name\n        role = role.getName();\n      }\n      if (typeof role !== 'string') {\n        throw new TypeError('role must be a ParseRole or a String');\n      }\n      return this.getWriteAccess('role:' + role);\n    }\n\n    /**\n     * Sets whether users belonging to the given role are allowed\n     * to read this object.\n     *\n     * @param role The name of the role, or a Parse.Role object.\n     * @param {boolean} allowed Whether the given role can read this object.\n     * @throws {TypeError} If role is neither a Parse.Role nor a String.\n     */\n  }, {\n    key: \"setRoleReadAccess\",\n    value: function (role /*: ParseRole | string*/, allowed /*: boolean*/) {\n      if (role instanceof _ParseRole.default) {\n        // Normalize to the String name\n        role = role.getName();\n      }\n      if (typeof role !== 'string') {\n        throw new TypeError('role must be a ParseRole or a String');\n      }\n      this.setReadAccess('role:' + role, allowed);\n    }\n\n    /**\n     * Sets whether users belonging to the given role are allowed\n     * to write this object.\n     *\n     * @param role The name of the role, or a Parse.Role object.\n     * @param {boolean} allowed Whether the given role can write this object.\n     * @throws {TypeError} If role is neither a Parse.Role nor a String.\n     */\n  }, {\n    key: \"setRoleWriteAccess\",\n    value: function (role /*: ParseRole | string*/, allowed /*: boolean*/) {\n      if (role instanceof _ParseRole.default) {\n        // Normalize to the String name\n        role = role.getName();\n      }\n      if (typeof role !== 'string') {\n        throw new TypeError('role must be a ParseRole or a String');\n      }\n      this.setWriteAccess('role:' + role, allowed);\n    }\n  }]);\n  return ParseACL;\n}();\nvar _default = ParseACL;\nexports.default = _default;"],"mappings":"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"},"metadata":{},"sourceType":"script","externalDependencies":[]}