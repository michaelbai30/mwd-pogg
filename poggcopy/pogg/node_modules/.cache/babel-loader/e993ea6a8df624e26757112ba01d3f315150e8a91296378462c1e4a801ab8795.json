{"ast":null,"code":"\"use strict\";\n\nvar _Object$defineProperty = require(\"@babel/runtime-corejs3/core-js-stable/object/define-property\");\nvar _interopRequireDefault = require(\"@babel/runtime-corejs3/helpers/interopRequireDefault\");\n_Object$defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.default = void 0;\nvar _regenerator = _interopRequireDefault(require(\"@babel/runtime-corejs3/regenerator\"));\nvar _slicedToArray2 = _interopRequireDefault(require(\"@babel/runtime-corejs3/helpers/slicedToArray\"));\nvar _toConsumableArray2 = _interopRequireDefault(require(\"@babel/runtime-corejs3/helpers/toConsumableArray\"));\nvar _asyncToGenerator2 = _interopRequireDefault(require(\"@babel/runtime-corejs3/helpers/asyncToGenerator\"));\nvar _classCallCheck2 = _interopRequireDefault(require(\"@babel/runtime-corejs3/helpers/classCallCheck\"));\nvar _createClass2 = _interopRequireDefault(require(\"@babel/runtime-corejs3/helpers/createClass\"));\nvar _defineProperty2 = _interopRequireDefault(require(\"@babel/runtime-corejs3/helpers/defineProperty\"));\nvar _typeof2 = _interopRequireDefault(require(\"@babel/runtime-corejs3/helpers/typeof\"));\nvar _forEach = _interopRequireDefault(require(\"@babel/runtime-corejs3/core-js-stable/instance/for-each\"));\nvar _indexOf = _interopRequireDefault(require(\"@babel/runtime-corejs3/core-js-stable/instance/index-of\"));\nvar _keys = _interopRequireDefault(require(\"@babel/runtime-corejs3/core-js-stable/object/keys\"));\nvar _slice = _interopRequireDefault(require(\"@babel/runtime-corejs3/core-js-stable/instance/slice\"));\nvar _map2 = _interopRequireDefault(require(\"@babel/runtime-corejs3/core-js-stable/instance/map\"));\nvar _filter2 = _interopRequireDefault(require(\"@babel/runtime-corejs3/core-js-stable/instance/filter\"));\nvar _keys2 = _interopRequireDefault(require(\"@babel/runtime-corejs3/core-js-stable/instance/keys\"));\nvar _concat = _interopRequireDefault(require(\"@babel/runtime-corejs3/core-js-stable/instance/concat\"));\nvar _includes = _interopRequireDefault(require(\"@babel/runtime-corejs3/core-js-stable/instance/includes\"));\nvar _sort = _interopRequireDefault(require(\"@babel/runtime-corejs3/core-js-stable/instance/sort\"));\nvar _splice = _interopRequireDefault(require(\"@babel/runtime-corejs3/core-js-stable/instance/splice\"));\nvar _promise = _interopRequireDefault(require(\"@babel/runtime-corejs3/core-js-stable/promise\"));\nvar _find = _interopRequireDefault(require(\"@babel/runtime-corejs3/core-js-stable/instance/find\"));\nvar _isArray = _interopRequireDefault(require(\"@babel/runtime-corejs3/core-js-stable/array/is-array\"));\nvar _entries = _interopRequireDefault(require(\"@babel/runtime-corejs3/core-js-stable/object/entries\"));\nvar _CoreManager = _interopRequireDefault(require(\"./CoreManager\"));\nvar _encode = _interopRequireDefault(require(\"./encode\"));\nvar _promiseUtils = require(\"./promiseUtils\");\nvar _ParseError = _interopRequireDefault(require(\"./ParseError\"));\nvar _ParseGeoPoint = _interopRequireDefault(require(\"./ParseGeoPoint\"));\nvar _ParseObject = _interopRequireDefault(require(\"./ParseObject\"));\nvar _OfflineQuery = _interopRequireDefault(require(\"./OfflineQuery\"));\nvar _LocalDatastoreUtils = require(\"./LocalDatastoreUtils\");\n/*\n * @flow\n */\n/*:: import type LiveQuerySubscription from './LiveQuerySubscription';*/\n/*:: import type { RequestOptions, FullOptions } from './RESTController';*/\n/*:: type BatchOptions = FullOptions & { batchSize?: number };*/\n/*:: export type WhereClause = {\n  [attr: string]: mixed,\n};*/\n/*:: export type QueryJSON = {\n  where: WhereClause,\n  watch?: string,\n  include?: string,\n  excludeKeys?: string,\n  keys?: string,\n  limit?: number,\n  skip?: number,\n  order?: string,\n  className?: string,\n  count?: number,\n  hint?: mixed,\n  explain?: boolean,\n  readPreference?: string,\n  includeReadPreference?: string,\n  subqueryReadPreference?: string,\n};*/\n/**\n * Converts a string into a regex that matches it.\n * Surrounding with \\Q .. \\E does this, we just need to escape any \\E's in\n * the text separately.\n *\n * @param s\n * @private\n * @returns {string}\n */\nfunction quote(s /*: string*/) /*: string*/{\n  return '\\\\Q' + s.replace('\\\\E', '\\\\E\\\\\\\\E\\\\Q') + '\\\\E';\n}\n\n/**\n * Extracts the class name from queries. If not all queries have the same\n * class name an error will be thrown.\n *\n * @param queries\n * @private\n * @returns {string}\n */\nfunction _getClassNameFromQueries(queries /*: Array<ParseQuery>*/) /*: ?string*/{\n  var className = null;\n  (0, _forEach.default)(queries).call(queries, function (q) {\n    if (!className) {\n      className = q.className;\n    }\n    if (className !== q.className) {\n      throw new Error('All queries must be for the same class.');\n    }\n  });\n  return className;\n}\n\n/*\n * Handles pre-populating the result data of a query with select fields,\n * making sure that the data object contains keys for all objects that have\n * been requested with a select, so that our cached state updates correctly.\n */\nfunction handleSelectResult(data /*: any*/, select /*: Array<string>*/) {\n  var serverDataMask = {};\n  (0, _forEach.default)(select).call(select, function (field) {\n    var hasSubObjectSelect = (0, _indexOf.default)(field).call(field, '.') !== -1;\n    if (!hasSubObjectSelect && !data.hasOwnProperty(field)) {\n      // this field was selected, but is missing from the retrieved data\n      data[field] = undefined;\n    } else if (hasSubObjectSelect) {\n      // this field references a sub-object,\n      // so we need to walk down the path components\n      var pathComponents = field.split('.');\n      var _obj = data;\n      var serverMask = serverDataMask;\n      (0, _forEach.default)(pathComponents).call(pathComponents, function (component, index, arr) {\n        // add keys if the expected data is missing\n        if (_obj && !_obj.hasOwnProperty(component)) {\n          _obj[component] = undefined;\n        }\n        if (_obj && (0, _typeof2.default)(_obj) === 'object') {\n          _obj = _obj[component];\n        }\n\n        //add this path component to the server mask so we can fill it in later if needed\n        if (index < arr.length - 1) {\n          if (!serverMask[component]) {\n            serverMask[component] = {};\n          }\n          serverMask = serverMask[component];\n        }\n      });\n    }\n  });\n  if ((0, _keys.default)(serverDataMask).length > 0) {\n    // When selecting from sub-objects, we don't want to blow away the missing\n    // information that we may have retrieved before. We've already added any\n    // missing selected keys to sub-objects, but we still need to add in the\n    // data for any previously retrieved sub-objects that were not selected.\n\n    var serverData = _CoreManager.default.getObjectStateController().getServerData({\n      id: data.objectId,\n      className: data.className\n    });\n    copyMissingDataWithMask(serverData, data, serverDataMask, false);\n  }\n}\nfunction copyMissingDataWithMask(src, dest, mask, copyThisLevel) {\n  //copy missing elements at this level\n  if (copyThisLevel) {\n    for (var _key in src) {\n      if (src.hasOwnProperty(_key) && !dest.hasOwnProperty(_key)) {\n        dest[_key] = src[_key];\n      }\n    }\n  }\n  for (var _key2 in mask) {\n    if (dest[_key2] !== undefined && dest[_key2] !== null && src !== undefined && src !== null) {\n      //traverse into objects as needed\n      copyMissingDataWithMask(src[_key2], dest[_key2], mask[_key2], true);\n    }\n  }\n}\nfunction handleOfflineSort(a, b, sorts) {\n  var order = sorts[0];\n  var operator = (0, _slice.default)(order).call(order, 0, 1);\n  var isDescending = operator === '-';\n  if (isDescending) {\n    order = order.substring(1);\n  }\n  if (order === '_created_at') {\n    order = 'createdAt';\n  }\n  if (order === '_updated_at') {\n    order = 'updatedAt';\n  }\n  if (!/^[A-Za-z][0-9A-Za-z_]*$/.test(order) || order === 'password') {\n    throw new _ParseError.default(_ParseError.default.INVALID_KEY_NAME, \"Invalid Key: \".concat(order));\n  }\n  var field1 = a.get(order);\n  var field2 = b.get(order);\n  if (field1 < field2) {\n    return isDescending ? 1 : -1;\n  }\n  if (field1 > field2) {\n    return isDescending ? -1 : 1;\n  }\n  if (sorts.length > 1) {\n    var remainingSorts = (0, _slice.default)(sorts).call(sorts, 1);\n    return handleOfflineSort(a, b, remainingSorts);\n  }\n  return 0;\n}\n/**\n * Creates a new parse Parse.Query for the given Parse.Object subclass.\n *\n * <p>Parse.Query defines a query that is used to fetch Parse.Objects. The\n * most common use case is finding all objects that match a query through the\n * <code>find</code> method. for example, this sample code fetches all objects\n * of class <code>myclass</code>. it calls a different function depending on\n * whether the fetch succeeded or not.\n *\n * <pre>\n * var query = new Parse.Query(myclass);\n * query.find().then((results) => {\n *   // results is an array of parse.object.\n * }).catch((error) =>  {\n *  // error is an instance of parse.error.\n * });</pre></p>\n *\n * <p>a Parse.Query can also be used to retrieve a single object whose id is\n * known, through the get method. for example, this sample code fetches an\n * object of class <code>myclass</code> and id <code>myid</code>. it calls a\n * different function depending on whether the fetch succeeded or not.\n *\n * <pre>\n * var query = new Parse.Query(myclass);\n * query.get(myid).then((object) => {\n *     // object is an instance of parse.object.\n * }).catch((error) =>  {\n *  // error is an instance of parse.error.\n * });</pre></p>\n *\n * <p>a Parse.Query can also be used to count the number of objects that match\n * the query without retrieving all of those objects. for example, this\n * sample code counts the number of objects of the class <code>myclass</code>\n * <pre>\n * var query = new Parse.Query(myclass);\n * query.count().then((number) => {\n *     // there are number instances of myclass.\n * }).catch((error) => {\n *     // error is an instance of Parse.Error.\n * });</pre></p>\n *\n * @alias Parse.Query\n */\nvar ParseQuery = /*#__PURE__*/function () {\n  /**\n   * @param {(string | Parse.Object)} objectClass An instance of a subclass of Parse.Object, or a Parse className string.\n   */\n  function ParseQuery(objectClass /*: string | ParseObject*/) {\n    (0, _classCallCheck2.default)(this, ParseQuery);\n    /**\n     * @property {string} className\n     */\n    (0, _defineProperty2.default)(this, \"className\", void 0);\n    (0, _defineProperty2.default)(this, \"_where\", void 0);\n    (0, _defineProperty2.default)(this, \"_watch\", void 0);\n    (0, _defineProperty2.default)(this, \"_include\", void 0);\n    (0, _defineProperty2.default)(this, \"_exclude\", void 0);\n    (0, _defineProperty2.default)(this, \"_select\", void 0);\n    (0, _defineProperty2.default)(this, \"_limit\", void 0);\n    (0, _defineProperty2.default)(this, \"_skip\", void 0);\n    (0, _defineProperty2.default)(this, \"_count\", void 0);\n    (0, _defineProperty2.default)(this, \"_order\", void 0);\n    (0, _defineProperty2.default)(this, \"_readPreference\", void 0);\n    (0, _defineProperty2.default)(this, \"_includeReadPreference\", void 0);\n    (0, _defineProperty2.default)(this, \"_subqueryReadPreference\", void 0);\n    (0, _defineProperty2.default)(this, \"_queriesLocalDatastore\", void 0);\n    (0, _defineProperty2.default)(this, \"_localDatastorePinName\", void 0);\n    (0, _defineProperty2.default)(this, \"_extraOptions\", void 0);\n    (0, _defineProperty2.default)(this, \"_hint\", void 0);\n    (0, _defineProperty2.default)(this, \"_explain\", void 0);\n    (0, _defineProperty2.default)(this, \"_xhrRequest\", void 0);\n    if (typeof objectClass === 'string') {\n      if (objectClass === 'User' && _CoreManager.default.get('PERFORM_USER_REWRITE')) {\n        this.className = '_User';\n      } else {\n        this.className = objectClass;\n      }\n    } else if (objectClass instanceof _ParseObject.default) {\n      this.className = objectClass.className;\n    } else if (typeof objectClass === 'function') {\n      if (typeof objectClass.className === 'string') {\n        this.className = objectClass.className;\n      } else {\n        var _obj2 = new objectClass();\n        this.className = _obj2.className;\n      }\n    } else {\n      throw new TypeError('A ParseQuery must be constructed with a ParseObject or class name.');\n    }\n    this._where = {};\n    this._watch = [];\n    this._include = [];\n    this._exclude = [];\n    this._count = false;\n    this._limit = -1; // negative limit is not sent in the server request\n    this._skip = 0;\n    this._readPreference = null;\n    this._includeReadPreference = null;\n    this._subqueryReadPreference = null;\n    this._queriesLocalDatastore = false;\n    this._localDatastorePinName = null;\n    this._extraOptions = {};\n    this._xhrRequest = {\n      task: null,\n      onchange: function () {}\n    };\n  }\n\n  /**\n   * Adds constraint that at least one of the passed in queries matches.\n   *\n   * @param {Array} queries\n   * @returns {Parse.Query} Returns the query, so you can chain this call.\n   */\n  (0, _createClass2.default)(ParseQuery, [{\n    key: \"_orQuery\",\n    value: function (queries /*: Array<ParseQuery>*/) /*: ParseQuery*/{\n      var queryJSON = (0, _map2.default)(queries).call(queries, function (q) {\n        return q.toJSON().where;\n      });\n      this._where.$or = queryJSON;\n      return this;\n    }\n\n    /**\n     * Adds constraint that all of the passed in queries match.\n     *\n     * @param {Array} queries\n     * @returns {Parse.Query} Returns the query, so you can chain this call.\n     */\n  }, {\n    key: \"_andQuery\",\n    value: function (queries /*: Array<ParseQuery>*/) /*: ParseQuery*/{\n      var queryJSON = (0, _map2.default)(queries).call(queries, function (q) {\n        return q.toJSON().where;\n      });\n      this._where.$and = queryJSON;\n      return this;\n    }\n\n    /**\n     * Adds constraint that none of the passed in queries match.\n     *\n     * @param {Array} queries\n     * @returns {Parse.Query} Returns the query, so you can chain this call.\n     */\n  }, {\n    key: \"_norQuery\",\n    value: function (queries /*: Array<ParseQuery>*/) /*: ParseQuery*/{\n      var queryJSON = (0, _map2.default)(queries).call(queries, function (q) {\n        return q.toJSON().where;\n      });\n      this._where.$nor = queryJSON;\n      return this;\n    }\n\n    /**\n     * Helper for condition queries\n     *\n     * @param key\n     * @param condition\n     * @param value\n     * @returns {Parse.Query}\n     */\n  }, {\n    key: \"_addCondition\",\n    value: function (key /*: string*/, condition /*: string*/, value /*: mixed*/) /*: ParseQuery*/{\n      if (!this._where[key] || typeof this._where[key] === 'string') {\n        this._where[key] = {};\n      }\n      this._where[key][condition] = (0, _encode.default)(value, false, true);\n      return this;\n    }\n\n    /**\n     * Converts string for regular expression at the beginning\n     *\n     * @param string\n     * @returns {string}\n     */\n  }, {\n    key: \"_regexStartWith\",\n    value: function (string /*: string*/) /*: string*/{\n      return '^' + quote(string);\n    }\n  }, {\n    key: \"_handleOfflineQuery\",\n    value: function () {\n      var _handleOfflineQuery2 = (0, _asyncToGenerator2.default)( /*#__PURE__*/_regenerator.default.mark(function _callee(params /*: any*/) {\n        var _context,\n          _this2 = this;\n        var localDatastore, objects, results, keys, alwaysSelectedKeys, sorts, count, limit;\n        return _regenerator.default.wrap(function (_context3) {\n          while (1) switch (_context3.prev = _context3.next) {\n            case 0:\n              _OfflineQuery.default.validateQuery(this);\n              localDatastore = _CoreManager.default.getLocalDatastore();\n              _context3.next = 4;\n              return localDatastore._serializeObjectsFromPinName(this._localDatastorePinName);\n            case 4:\n              objects = _context3.sent;\n              results = (0, _filter2.default)(_context = (0, _map2.default)(objects).call(objects, function (json, index, arr) {\n                var object = _ParseObject.default.fromJSON(json, false);\n                if (json._localId && !json.objectId) {\n                  object._localId = json._localId;\n                }\n                if (!_OfflineQuery.default.matchesQuery(_this2.className, object, arr, _this2)) {\n                  return null;\n                }\n                return object;\n              })).call(_context, function (object) {\n                return object !== null;\n              });\n              if ((0, _keys2.default)(params)) {\n                keys = (0, _keys2.default)(params).split(',');\n                alwaysSelectedKeys = ['className', 'objectId', 'createdAt', 'updatedAt', 'ACL'];\n                keys = (0, _concat.default)(keys).call(keys, alwaysSelectedKeys);\n                results = (0, _map2.default)(results).call(results, function (object) {\n                  var _context2;\n                  var json = object._toFullJSON();\n                  (0, _forEach.default)(_context2 = (0, _keys.default)(json)).call(_context2, function (key) {\n                    if (!(0, _includes.default)(keys).call(keys, key)) {\n                      delete json[key];\n                    }\n                  });\n                  return _ParseObject.default.fromJSON(json, false);\n                });\n              }\n              if (params.order) {\n                sorts = params.order.split(',');\n                (0, _sort.default)(results).call(results, function (a, b) {\n                  return handleOfflineSort(a, b, sorts);\n                });\n              }\n              // count total before applying limit/skip\n              if (params.count) {\n                count = results.length; // total count from response\n              }\n\n              if (params.skip) {\n                if (params.skip >= results.length) {\n                  results = [];\n                } else {\n                  results = (0, _splice.default)(results).call(results, params.skip, results.length);\n                }\n              }\n              limit = results.length;\n              if (params.limit !== 0 && params.limit < results.length) {\n                limit = params.limit;\n              }\n              results = (0, _splice.default)(results).call(results, 0, limit);\n              if (!(typeof count === 'number')) {\n                _context3.next = 15;\n                break;\n              }\n              return _context3.abrupt(\"return\", {\n                results: results,\n                count: count\n              });\n            case 15:\n              return _context3.abrupt(\"return\", results);\n            case 16:\n            case \"end\":\n              return _context3.stop();\n          }\n        }, _callee, this);\n      }));\n      function _handleOfflineQuery() {\n        return _handleOfflineQuery2.apply(this, arguments);\n      }\n      return _handleOfflineQuery;\n    }()\n    /**\n     * Returns a JSON representation of this query.\n     *\n     * @returns {object} The JSON representation of the query.\n     */\n  }, {\n    key: \"toJSON\",\n    value: function () /*: QueryJSON*/{\n      var params /*: QueryJSON*/ = {\n        where: this._where\n      };\n      if (this._watch.length) {\n        params.watch = this._watch.join(',');\n      }\n      if (this._include.length) {\n        params.include = this._include.join(',');\n      }\n      if (this._exclude.length) {\n        params.excludeKeys = this._exclude.join(',');\n      }\n      if (this._select) {\n        params.keys = this._select.join(',');\n      }\n      if (this._count) {\n        params.count = 1;\n      }\n      if (this._limit >= 0) {\n        params.limit = this._limit;\n      }\n      if (this._skip > 0) {\n        params.skip = this._skip;\n      }\n      if (this._order) {\n        params.order = this._order.join(',');\n      }\n      if (this._readPreference) {\n        params.readPreference = this._readPreference;\n      }\n      if (this._includeReadPreference) {\n        params.includeReadPreference = this._includeReadPreference;\n      }\n      if (this._subqueryReadPreference) {\n        params.subqueryReadPreference = this._subqueryReadPreference;\n      }\n      if (this._hint) {\n        params.hint = this._hint;\n      }\n      if (this._explain) {\n        params.explain = true;\n      }\n      for (var _key3 in this._extraOptions) {\n        params[_key3] = this._extraOptions[_key3];\n      }\n      return params;\n    }\n\n    /**\n     * Return a query with conditions from json, can be useful to send query from server side to client\n     * Not static, all query conditions was set before calling this method will be deleted.\n     * For example on the server side we have\n     * var query = new Parse.Query(\"className\");\n     * query.equalTo(key: value);\n     * query.limit(100);\n     * ... (others queries)\n     * Create JSON representation of Query Object\n     * var jsonFromServer = query.fromJSON();\n     *\n     * On client side getting query:\n     * var query = new Parse.Query(\"className\");\n     * query.fromJSON(jsonFromServer);\n     *\n     * and continue to query...\n     * query.skip(100).find().then(...);\n     *\n     * @param {QueryJSON} json from Parse.Query.toJSON() method\n     * @returns {Parse.Query} Returns the query, so you can chain this call.\n     */\n  }, {\n    key: \"withJSON\",\n    value: function (json /*: QueryJSON*/) /*: ParseQuery*/{\n      if (json.where) {\n        this._where = json.where;\n      }\n      if (json.watch) {\n        this._watch = json.watch.split(',');\n      }\n      if (json.include) {\n        this._include = json.include.split(',');\n      }\n      if ((0, _keys2.default)(json)) {\n        this._select = (0, _keys2.default)(json).split(',');\n      }\n      if (json.excludeKeys) {\n        this._exclude = json.excludeKeys.split(',');\n      }\n      if (json.count) {\n        this._count = json.count === 1;\n      }\n      if (json.limit) {\n        this._limit = json.limit;\n      }\n      if (json.skip) {\n        this._skip = json.skip;\n      }\n      if (json.order) {\n        this._order = json.order.split(',');\n      }\n      if (json.readPreference) {\n        this._readPreference = json.readPreference;\n      }\n      if (json.includeReadPreference) {\n        this._includeReadPreference = json.includeReadPreference;\n      }\n      if (json.subqueryReadPreference) {\n        this._subqueryReadPreference = json.subqueryReadPreference;\n      }\n      if (json.hint) {\n        this._hint = json.hint;\n      }\n      if (json.explain) {\n        this._explain = !!json.explain;\n      }\n      for (var _key4 in json) {\n        if (json.hasOwnProperty(_key4)) {\n          var _context4;\n          if ((0, _indexOf.default)(_context4 = ['where', 'include', 'keys', 'count', 'limit', 'skip', 'order', 'readPreference', 'includeReadPreference', 'subqueryReadPreference', 'hint', 'explain']).call(_context4, _key4) === -1) {\n            this._extraOptions[_key4] = json[_key4];\n          }\n        }\n      }\n      return this;\n    }\n\n    /**\n     * Static method to restore Parse.Query by json representation\n     * Internally calling Parse.Query.withJSON\n     *\n     * @param {string} className\n     * @param {QueryJSON} json from Parse.Query.toJSON() method\n     * @returns {Parse.Query} new created query\n     */\n  }, {\n    key: \"get\",\n    value:\n    /**\n     * Constructs a Parse.Object whose id is already known by fetching data from\n     * the server. Unlike the <code>first</code> method, it never returns undefined.\n     *\n     * @param {string} objectId The id of the object to be fetched.\n     * @param {object} options\n     * Valid options are:<ul>\n     *   <li>useMasterKey: In Cloud Code and Node only, causes the Master Key to\n     *     be used for this request.\n     *   <li>sessionToken: A valid session token, used for making a request on\n     *       behalf of a specific user.\n     *   <li>context: A dictionary that is accessible in Cloud Code `beforeFind` trigger.\n     *   <li>json: Return raw json without converting to Parse.Object\n     * </ul>\n     * @returns {Promise} A promise that is resolved with the result when\n     * the query completes.\n     */\n    function (objectId /*: string*/, options /*:: ?: FullOptions*/) /*: Promise<ParseObject>*/{\n      this.equalTo('objectId', objectId);\n      var firstOptions = {};\n      if (options && options.hasOwnProperty('useMasterKey')) {\n        firstOptions.useMasterKey = options.useMasterKey;\n      }\n      if (options && options.hasOwnProperty('sessionToken')) {\n        firstOptions.sessionToken = options.sessionToken;\n      }\n      if (options && options.hasOwnProperty('context') && (0, _typeof2.default)(options.context) === 'object') {\n        firstOptions.context = options.context;\n      }\n      if (options && options.hasOwnProperty('json')) {\n        firstOptions.json = options.json;\n      }\n      return this.first(firstOptions).then(function (response) {\n        if (response) {\n          return response;\n        }\n        var errorObject = new _ParseError.default(_ParseError.default.OBJECT_NOT_FOUND, 'Object not found.');\n        return _promise.default.reject(errorObject);\n      });\n    }\n\n    /**\n     * Retrieves a list of ParseObjects that satisfy this query.\n     *\n     * @param {object} options Valid options\n     * are:<ul>\n     *   <li>useMasterKey: In Cloud Code and Node only, causes the Master Key to\n     *     be used for this request.\n     *   <li>sessionToken: A valid session token, used for making a request on\n     *       behalf of a specific user.\n     *   <li>context: A dictionary that is accessible in Cloud Code `beforeFind` trigger.\n     *   <li>json: Return raw json without converting to Parse.Object\n     * </ul>\n     * @returns {Promise} A promise that is resolved with the results when\n     * the query completes.\n     */\n  }, {\n    key: \"find\",\n    value: function (options /*:: ?: FullOptions*/) /*: Promise<Array<ParseObject>>*/{\n      var _this3 = this;\n      options = options || {};\n      var findOptions = {};\n      if (options.hasOwnProperty('useMasterKey')) {\n        findOptions.useMasterKey = options.useMasterKey;\n      }\n      if (options.hasOwnProperty('sessionToken')) {\n        findOptions.sessionToken = options.sessionToken;\n      }\n      if (options.hasOwnProperty('context') && (0, _typeof2.default)(options.context) === 'object') {\n        findOptions.context = options.context;\n      }\n      this._setRequestTask(findOptions);\n      var controller = _CoreManager.default.getQueryController();\n      var select = this._select;\n      if (this._queriesLocalDatastore) {\n        return this._handleOfflineQuery(this.toJSON());\n      }\n      return (0, _find.default)(controller).call(controller, this.className, this.toJSON(), findOptions).then(function (response) {\n        var _context5;\n        // Return generic object when explain is used\n        if (_this3._explain) {\n          return response.results;\n        }\n        var results = (0, _map2.default)(_context5 = response.results).call(_context5, function (data) {\n          // In cases of relations, the server may send back a className\n          // on the top level of the payload\n          var override = response.className || _this3.className;\n          if (!data.className) {\n            data.className = override;\n          }\n\n          // Make sure the data object contains keys for all objects that\n          // have been requested with a select, so that our cached state\n          // updates correctly.\n          if (select) {\n            handleSelectResult(data, select);\n          }\n          if (options.json) {\n            return data;\n          } else {\n            return _ParseObject.default.fromJSON(data, !select);\n          }\n        });\n        var count = response.count;\n        if (typeof count === 'number') {\n          return {\n            results: results,\n            count: count\n          };\n        } else {\n          return results;\n        }\n      });\n    }\n\n    /**\n     * Retrieves a complete list of ParseObjects that satisfy this query.\n     * Using `eachBatch` under the hood to fetch all the valid objects.\n     *\n     * @param {object} options Valid options are:<ul>\n     *   <li>batchSize: How many objects to yield in each batch (default: 100)\n     *   <li>useMasterKey: In Cloud Code and Node only, causes the Master Key to\n     *     be used for this request.\n     *   <li>sessionToken: A valid session token, used for making a request on\n     *       behalf of a specific user.\n     * </ul>\n     * @returns {Promise} A promise that is resolved with the results when\n     * the query completes.\n     */\n  }, {\n    key: \"findAll\",\n    value: function () {\n      var _findAll = (0, _asyncToGenerator2.default)( /*#__PURE__*/_regenerator.default.mark(function _callee2(options /*:: ?: BatchOptions*/) {\n        var result;\n        return _regenerator.default.wrap(function (_context7) {\n          while (1) switch (_context7.prev = _context7.next) {\n            case 0:\n              result /*: ParseObject[]*/ = [];\n              _context7.next = 3;\n              return this.eachBatch(function (objects /*: ParseObject[]*/) {\n                var _context6;\n                result = (0, _concat.default)(_context6 = []).call(_context6, (0, _toConsumableArray2.default)(result), (0, _toConsumableArray2.default)(objects));\n              }, options);\n            case 3:\n              return _context7.abrupt(\"return\", result);\n            case 4:\n            case \"end\":\n              return _context7.stop();\n          }\n        }, _callee2, this);\n      }));\n      function findAll() {\n        return _findAll.apply(this, arguments);\n      }\n      return findAll;\n    }()\n    /**\n     * Counts the number of objects that match this query.\n     *\n     * @param {object} options\n     * Valid options are:<ul>\n     *   <li>useMasterKey: In Cloud Code and Node only, causes the Master Key to\n     *     be used for this request.\n     *   <li>sessionToken: A valid session token, used for making a request on\n     *       behalf of a specific user.\n     * </ul>\n     * @returns {Promise} A promise that is resolved with the count when\n     * the query completes.\n     */\n  }, {\n    key: \"count\",\n    value: function (options /*:: ?: FullOptions*/) /*: Promise<number>*/{\n      options = options || {};\n      var findOptions = {};\n      if (options.hasOwnProperty('useMasterKey')) {\n        findOptions.useMasterKey = options.useMasterKey;\n      }\n      if (options.hasOwnProperty('sessionToken')) {\n        findOptions.sessionToken = options.sessionToken;\n      }\n      this._setRequestTask(findOptions);\n      var controller = _CoreManager.default.getQueryController();\n      var params = this.toJSON();\n      params.limit = 0;\n      params.count = 1;\n      return (0, _find.default)(controller).call(controller, this.className, params, findOptions).then(function (result) {\n        return result.count;\n      });\n    }\n\n    /**\n     * Executes a distinct query and returns unique values\n     *\n     * @param {string} key A field to find distinct values\n     * @param {object} options\n     * Valid options are:<ul>\n     *   <li>sessionToken: A valid session token, used for making a request on\n     *       behalf of a specific user.\n     * </ul>\n     * @returns {Promise} A promise that is resolved with the query completes.\n     */\n  }, {\n    key: \"distinct\",\n    value: function (key /*: string*/, options /*:: ?: FullOptions*/) /*: Promise<Array<mixed>>*/{\n      options = options || {};\n      var distinctOptions = {};\n      distinctOptions.useMasterKey = true;\n      if (options.hasOwnProperty('sessionToken')) {\n        distinctOptions.sessionToken = options.sessionToken;\n      }\n      this._setRequestTask(distinctOptions);\n      var controller = _CoreManager.default.getQueryController();\n      var params = {\n        distinct: key,\n        where: this._where,\n        hint: this._hint\n      };\n      return controller.aggregate(this.className, params, distinctOptions).then(function (results) {\n        return results.results;\n      });\n    }\n\n    /**\n     * Executes an aggregate query and returns aggregate results\n     *\n     * @param {(Array|object)} pipeline Array or Object of stages to process query\n     * @param {object} options Valid options are:<ul>\n     *   <li>sessionToken: A valid session token, used for making a request on\n     *       behalf of a specific user.\n     * </ul>\n     * @returns {Promise} A promise that is resolved with the query completes.\n     */\n  }, {\n    key: \"aggregate\",\n    value: function (pipeline /*: mixed*/, options /*:: ?: FullOptions*/) /*: Promise<Array<mixed>>*/{\n      options = options || {};\n      var aggregateOptions = {};\n      aggregateOptions.useMasterKey = true;\n      if (options.hasOwnProperty('sessionToken')) {\n        aggregateOptions.sessionToken = options.sessionToken;\n      }\n      this._setRequestTask(aggregateOptions);\n      var controller = _CoreManager.default.getQueryController();\n      if (!(0, _isArray.default)(pipeline) && (0, _typeof2.default)(pipeline) !== 'object') {\n        throw new Error('Invalid pipeline must be Array or Object');\n      }\n      if ((0, _keys.default)(this._where || {}).length) {\n        if (!(0, _isArray.default)(pipeline)) {\n          pipeline = [pipeline];\n        }\n        pipeline.unshift({\n          $match: this._where\n        });\n      }\n      var params = {\n        pipeline: pipeline,\n        hint: this._hint,\n        explain: this._explain,\n        readPreference: this._readPreference\n      };\n      return controller.aggregate(this.className, params, aggregateOptions).then(function (results) {\n        return results.results;\n      });\n    }\n\n    /**\n     * Retrieves at most one Parse.Object that satisfies this query.\n     *\n     * Returns the object if there is one, otherwise undefined.\n     *\n     * @param {object} options Valid options are:<ul>\n     *   <li>useMasterKey: In Cloud Code and Node only, causes the Master Key to\n     *     be used for this request.\n     *   <li>sessionToken: A valid session token, used for making a request on\n     *       behalf of a specific user.\n     *   <li>context: A dictionary that is accessible in Cloud Code `beforeFind` trigger.\n     *   <li>json: Return raw json without converting to Parse.Object\n     * </ul>\n     * @returns {Promise} A promise that is resolved with the object when\n     * the query completes.\n     */\n  }, {\n    key: \"first\",\n    value: function (options /*:: ?: FullOptions*/) /*: Promise<ParseObject | void>*/{\n      var _this4 = this;\n      options = options || {};\n      var findOptions = {};\n      if (options.hasOwnProperty('useMasterKey')) {\n        findOptions.useMasterKey = options.useMasterKey;\n      }\n      if (options.hasOwnProperty('sessionToken')) {\n        findOptions.sessionToken = options.sessionToken;\n      }\n      if (options.hasOwnProperty('context') && (0, _typeof2.default)(options.context) === 'object') {\n        findOptions.context = options.context;\n      }\n      this._setRequestTask(findOptions);\n      var controller = _CoreManager.default.getQueryController();\n      var params = this.toJSON();\n      params.limit = 1;\n      var select = this._select;\n      if (this._queriesLocalDatastore) {\n        return this._handleOfflineQuery(params).then(function (objects) {\n          if (!objects[0]) {\n            return undefined;\n          }\n          return objects[0];\n        });\n      }\n      return (0, _find.default)(controller).call(controller, this.className, params, findOptions).then(function (response) {\n        var objects = response.results;\n        if (!objects[0]) {\n          return undefined;\n        }\n        if (!objects[0].className) {\n          objects[0].className = _this4.className;\n        }\n\n        // Make sure the data object contains keys for all objects that\n        // have been requested with a select, so that our cached state\n        // updates correctly.\n        if (select) {\n          handleSelectResult(objects[0], select);\n        }\n        if (options.json) {\n          return objects[0];\n        } else {\n          return _ParseObject.default.fromJSON(objects[0], !select);\n        }\n      });\n    }\n\n    /**\n     * Iterates over objects matching a query, calling a callback for each batch.\n     * If the callback returns a promise, the iteration will not continue until\n     * that promise has been fulfilled. If the callback returns a rejected\n     * promise, then iteration will stop with that error. The items are processed\n     * in an unspecified order. The query may not have any sort order, and may\n     * not use limit or skip.\n     *\n     * @param {Function} callback Callback that will be called with each result\n     *     of the query.\n     * @param {object} options Valid options are:<ul>\n     *   <li>batchSize: How many objects to yield in each batch (default: 100)\n     *   <li>useMasterKey: In Cloud Code and Node only, causes the Master Key to\n     *     be used for this request.\n     *   <li>sessionToken: A valid session token, used for making a request on\n     *       behalf of a specific user.\n     *   <li>context: A dictionary that is accessible in Cloud Code `beforeFind` trigger.\n     * </ul>\n     * @returns {Promise} A promise that will be fulfilled once the\n     *     iteration has completed.\n     */\n  }, {\n    key: \"eachBatch\",\n    value: function (callback /*: (objs: Array<ParseObject>) => Promise<*>*/, options /*:: ?: BatchOptions*/) /*: Promise<void>*/{\n      var _context8;\n      options = options || {};\n      if (this._order || this._skip || this._limit >= 0) {\n        return _promise.default.reject('Cannot iterate on a query with sort, skip, or limit.');\n      }\n      var query = new ParseQuery(this.className);\n      query._limit = options.batchSize || 100;\n      query._include = (0, _map2.default)(_context8 = this._include).call(_context8, function (i) {\n        return i;\n      });\n      if (this._select) {\n        var _context9;\n        query._select = (0, _map2.default)(_context9 = this._select).call(_context9, function (s) {\n          return s;\n        });\n      }\n      query._hint = this._hint;\n      query._where = {};\n      for (var _attr in this._where) {\n        var val = this._where[_attr];\n        if ((0, _isArray.default)(val)) {\n          query._where[_attr] = (0, _map2.default)(val).call(val, function (v) {\n            return v;\n          });\n        } else if (val && (0, _typeof2.default)(val) === 'object') {\n          var conditionMap = {};\n          query._where[_attr] = conditionMap;\n          for (var cond in val) {\n            conditionMap[cond] = val[cond];\n          }\n        } else {\n          query._where[_attr] = val;\n        }\n      }\n      query.ascending('objectId');\n      var findOptions = {};\n      if (options.hasOwnProperty('useMasterKey')) {\n        findOptions.useMasterKey = options.useMasterKey;\n      }\n      if (options.hasOwnProperty('sessionToken')) {\n        findOptions.sessionToken = options.sessionToken;\n      }\n      if (options.hasOwnProperty('context') && (0, _typeof2.default)(options.context) === 'object') {\n        findOptions.context = options.context;\n      }\n      if (options.hasOwnProperty('json')) {\n        findOptions.json = options.json;\n      }\n      var finished = false;\n      var previousResults = [];\n      return (0, _promiseUtils.continueWhile)(function () {\n        return !finished;\n      }, /*#__PURE__*/(0, _asyncToGenerator2.default)( /*#__PURE__*/_regenerator.default.mark(function _callee3() {\n        var _yield$Promise$all, _yield$Promise$all2, results;\n        return _regenerator.default.wrap(function (_context10) {\n          while (1) switch (_context10.prev = _context10.next) {\n            case 0:\n              _context10.next = 2;\n              return _promise.default.all([(0, _find.default)(query).call(query, findOptions), _promise.default.resolve(previousResults.length > 0 && callback(previousResults))]);\n            case 2:\n              _yield$Promise$all = _context10.sent;\n              _yield$Promise$all2 = (0, _slicedToArray2.default)(_yield$Promise$all, 1);\n              results = _yield$Promise$all2[0];\n              if (!(results.length >= query._limit)) {\n                _context10.next = 10;\n                break;\n              }\n              query.greaterThan('objectId', results[results.length - 1].id);\n              previousResults = results;\n              _context10.next = 17;\n              break;\n            case 10:\n              if (!(results.length > 0)) {\n                _context10.next = 16;\n                break;\n              }\n              _context10.next = 13;\n              return _promise.default.resolve(callback(results));\n            case 13:\n              finished = true;\n              _context10.next = 17;\n              break;\n            case 16:\n              finished = true;\n            case 17:\n            case \"end\":\n              return _context10.stop();\n          }\n        }, _callee3);\n      })));\n    }\n\n    /**\n     * Iterates over each result of a query, calling a callback for each one. If\n     * the callback returns a promise, the iteration will not continue until\n     * that promise has been fulfilled. If the callback returns a rejected\n     * promise, then iteration will stop with that error. The items are\n     * processed in an unspecified order. The query may not have any sort order,\n     * and may not use limit or skip.\n     *\n     * @param {Function} callback Callback that will be called with each result\n     *     of the query.\n     * @param {object} options Valid options are:<ul>\n     *   <li>useMasterKey: In Cloud Code and Node only, causes the Master Key to\n     *     be used for this request.\n     *   <li>sessionToken: A valid session token, used for making a request on\n     *       behalf of a specific user.\n     *   <li>json: Return raw json without converting to Parse.Object\n     * </ul>\n     * @returns {Promise} A promise that will be fulfilled once the\n     *     iteration has completed.\n     */\n  }, {\n    key: \"each\",\n    value: function (callback /*: (obj: ParseObject) => any*/, options /*:: ?: BatchOptions*/) /*: Promise<void>*/{\n      return this.eachBatch(function (results) {\n        var callbacksDone = _promise.default.resolve();\n        (0, _forEach.default)(results).call(results, function (result) {\n          callbacksDone = callbacksDone.then(function () {\n            return callback(result);\n          });\n        });\n        return callbacksDone;\n      }, options);\n    }\n\n    /**\n     * Adds a hint to force index selection. (https://docs.mongodb.com/manual/reference/operator/meta/hint/)\n     *\n     * @param {(string|object)} value String or Object of index that should be used when executing query\n     * @returns {Parse.Query} Returns the query, so you can chain this call.\n     */\n  }, {\n    key: \"hint\",\n    value: function (value /*: mixed*/) /*: ParseQuery*/{\n      if (typeof value === 'undefined') {\n        delete this._hint;\n      }\n      this._hint = value;\n      return this;\n    }\n\n    /**\n     * Investigates the query execution plan. Useful for optimizing queries. (https://docs.mongodb.com/manual/reference/operator/meta/explain/)\n     *\n     * @param {boolean} explain Used to toggle the information on the query plan.\n     * @returns {Parse.Query} Returns the query, so you can chain this call.\n     */\n  }, {\n    key: \"explain\",\n    value: function () /*: ParseQuery*/{\n      var _explain /*: boolean*/ = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : true;\n      if (typeof _explain !== 'boolean') {\n        throw new Error('You can only set explain to a boolean value');\n      }\n      this._explain = _explain;\n      return this;\n    }\n\n    /**\n     * Iterates over each result of a query, calling a callback for each one. If\n     * the callback returns a promise, the iteration will not continue until\n     * that promise has been fulfilled. If the callback returns a rejected\n     * promise, then iteration will stop with that error. The items are\n     * processed in an unspecified order. The query may not have any sort order,\n     * and may not use limit or skip.\n     *\n     * @param {Function} callback Callback <ul>\n     *   <li>currentObject: The current Parse.Object being processed in the array.</li>\n     *   <li>index: The index of the current Parse.Object being processed in the array.</li>\n     *   <li>query: The query map was called upon.</li>\n     * </ul>\n     * @param {object} options Valid options are:<ul>\n     *   <li>useMasterKey: In Cloud Code and Node only, causes the Master Key to\n     *     be used for this request.\n     *   <li>sessionToken: A valid session token, used for making a request on\n     *       behalf of a specific user.\n     * </ul>\n     * @returns {Promise} A promise that will be fulfilled once the\n     *     iteration has completed.\n     */\n  }, {\n    key: \"map\",\n    value: function () {\n      var _map = (0, _asyncToGenerator2.default)( /*#__PURE__*/_regenerator.default.mark(function _callee4(callback /*: (currentObject: ParseObject, index: number, query: ParseQuery) => any*/, options /*:: ?: BatchOptions*/) {\n        var _this5 = this;\n        var array, index;\n        return _regenerator.default.wrap(function (_context11) {\n          while (1) switch (_context11.prev = _context11.next) {\n            case 0:\n              array = [];\n              index = 0;\n              _context11.next = 4;\n              return this.each(function (object) {\n                return _promise.default.resolve(callback(object, index, _this5)).then(function (result) {\n                  array.push(result);\n                  index += 1;\n                });\n              }, options);\n            case 4:\n              return _context11.abrupt(\"return\", array);\n            case 5:\n            case \"end\":\n              return _context11.stop();\n          }\n        }, _callee4, this);\n      }));\n      function map() {\n        return _map.apply(this, arguments);\n      }\n      return map;\n    }()\n    /**\n     * Iterates over each result of a query, calling a callback for each one. If\n     * the callback returns a promise, the iteration will not continue until\n     * that promise has been fulfilled. If the callback returns a rejected\n     * promise, then iteration will stop with that error. The items are\n     * processed in an unspecified order. The query may not have any sort order,\n     * and may not use limit or skip.\n     *\n     * @param {Function} callback Callback <ul>\n     *   <li>accumulator: The accumulator accumulates the callback's return values. It is the accumulated value previously returned in the last invocation of the callback.</li>\n     *   <li>currentObject: The current Parse.Object being processed in the array.</li>\n     *   <li>index: The index of the current Parse.Object being processed in the array.</li>\n     * </ul>\n     * @param {*} initialValue A value to use as the first argument to the first call of the callback. If no initialValue is supplied, the first object in the query will be used and skipped.\n     * @param {object} options Valid options are:<ul>\n     *   <li>useMasterKey: In Cloud Code and Node only, causes the Master Key to\n     *     be used for this request.\n     *   <li>sessionToken: A valid session token, used for making a request on\n     *       behalf of a specific user.\n     * </ul>\n     * @returns {Promise} A promise that will be fulfilled once the\n     *     iteration has completed.\n     */\n  }, {\n    key: \"reduce\",\n    value: function () {\n      var _reduce = (0, _asyncToGenerator2.default)( /*#__PURE__*/_regenerator.default.mark(function _callee5(callback /*: (accumulator: any, currentObject: ParseObject, index: number) => any*/, initialValue /*: any*/, options /*:: ?: BatchOptions*/) {\n        var accumulator, index;\n        return _regenerator.default.wrap(function (_context12) {\n          while (1) switch (_context12.prev = _context12.next) {\n            case 0:\n              accumulator = initialValue;\n              index = 0;\n              _context12.next = 4;\n              return this.each(function (object) {\n                // If no initial value was given, we take the first object from the query\n                // as the initial value and don't call the callback with it.\n                if (index === 0 && initialValue === undefined) {\n                  accumulator = object;\n                  index += 1;\n                  return;\n                }\n                return _promise.default.resolve(callback(accumulator, object, index)).then(function (result) {\n                  accumulator = result;\n                  index += 1;\n                });\n              }, options);\n            case 4:\n              if (!(index === 0 && initialValue === undefined)) {\n                _context12.next = 6;\n                break;\n              }\n              throw new TypeError('Reducing empty query result set with no initial value');\n            case 6:\n              return _context12.abrupt(\"return\", accumulator);\n            case 7:\n            case \"end\":\n              return _context12.stop();\n          }\n        }, _callee5, this);\n      }));\n      function reduce() {\n        return _reduce.apply(this, arguments);\n      }\n      return reduce;\n    }()\n    /**\n     * Iterates over each result of a query, calling a callback for each one. If\n     * the callback returns a promise, the iteration will not continue until\n     * that promise has been fulfilled. If the callback returns a rejected\n     * promise, then iteration will stop with that error. The items are\n     * processed in an unspecified order. The query may not have any sort order,\n     * and may not use limit or skip.\n     *\n     * @param {Function} callback Callback <ul>\n     *   <li>currentObject: The current Parse.Object being processed in the array.</li>\n     *   <li>index: The index of the current Parse.Object being processed in the array.</li>\n     *   <li>query: The query filter was called upon.</li>\n     * </ul>\n     * @param {object} options Valid options are:<ul>\n     *   <li>useMasterKey: In Cloud Code and Node only, causes the Master Key to\n     *     be used for this request.\n     *   <li>sessionToken: A valid session token, used for making a request on\n     *       behalf of a specific user.\n     * </ul>\n     * @returns {Promise} A promise that will be fulfilled once the\n     *     iteration has completed.\n     */\n  }, {\n    key: \"filter\",\n    value: function () {\n      var _filter = (0, _asyncToGenerator2.default)( /*#__PURE__*/_regenerator.default.mark(function _callee6(callback /*: (currentObject: ParseObject, index: number, query: ParseQuery) => boolean*/, options /*:: ?: BatchOptions*/) {\n        var _this6 = this;\n        var array, index;\n        return _regenerator.default.wrap(function (_context13) {\n          while (1) switch (_context13.prev = _context13.next) {\n            case 0:\n              array = [];\n              index = 0;\n              _context13.next = 4;\n              return this.each(function (object) {\n                return _promise.default.resolve(callback(object, index, _this6)).then(function (flag) {\n                  if (flag) {\n                    array.push(object);\n                  }\n                  index += 1;\n                });\n              }, options);\n            case 4:\n              return _context13.abrupt(\"return\", array);\n            case 5:\n            case \"end\":\n              return _context13.stop();\n          }\n        }, _callee6, this);\n      }));\n      function filter() {\n        return _filter.apply(this, arguments);\n      }\n      return filter;\n    }()\n    /* Query Conditions */\n    /**\n     * Adds a constraint to the query that requires a particular key's value to\n     * be equal to the provided value.\n     *\n     * @param {string} key The key to check.\n     * @param value The value that the Parse.Object must contain.\n     * @returns {Parse.Query} Returns the query, so you can chain this call.\n     */\n  }, {\n    key: \"equalTo\",\n    value: function (key /*: string | { [key: string]: any }*/, value /*: ?mixed*/) /*: ParseQuery*/{\n      var _this7 = this;\n      if (key && (0, _typeof2.default)(key) === 'object') {\n        var _context14;\n        (0, _forEach.default)(_context14 = (0, _entries.default)(key)).call(_context14, function (_ref2) {\n          var _ref3 = (0, _slicedToArray2.default)(_ref2, 2),\n            k = _ref3[0],\n            val = _ref3[1];\n          return _this7.equalTo(k, val);\n        });\n        return this;\n      }\n      if (typeof value === 'undefined') {\n        return this.doesNotExist(key);\n      }\n      this._where[key] = (0, _encode.default)(value, false, true);\n      return this;\n    }\n\n    /**\n     * Adds a constraint to the query that requires a particular key's value to\n     * be not equal to the provided value.\n     *\n     * @param {string} key The key to check.\n     * @param value The value that must not be equalled.\n     * @returns {Parse.Query} Returns the query, so you can chain this call.\n     */\n  }, {\n    key: \"notEqualTo\",\n    value: function (key /*: string | { [key: string]: any }*/, value /*: ?mixed*/) /*: ParseQuery*/{\n      var _this8 = this;\n      if (key && (0, _typeof2.default)(key) === 'object') {\n        var _context15;\n        (0, _forEach.default)(_context15 = (0, _entries.default)(key)).call(_context15, function (_ref4) {\n          var _ref5 = (0, _slicedToArray2.default)(_ref4, 2),\n            k = _ref5[0],\n            val = _ref5[1];\n          return _this8.notEqualTo(k, val);\n        });\n        return this;\n      }\n      return this._addCondition(key, '$ne', value);\n    }\n\n    /**\n     * Adds a constraint to the query that requires a particular key's value to\n     * be less than the provided value.\n     *\n     * @param {string} key The key to check.\n     * @param value The value that provides an upper bound.\n     * @returns {Parse.Query} Returns the query, so you can chain this call.\n     */\n  }, {\n    key: \"lessThan\",\n    value: function (key /*: string*/, value /*: mixed*/) /*: ParseQuery*/{\n      return this._addCondition(key, '$lt', value);\n    }\n\n    /**\n     * Adds a constraint to the query that requires a particular key's value to\n     * be greater than the provided value.\n     *\n     * @param {string} key The key to check.\n     * @param value The value that provides an lower bound.\n     * @returns {Parse.Query} Returns the query, so you can chain this call.\n     */\n  }, {\n    key: \"greaterThan\",\n    value: function (key /*: string*/, value /*: mixed*/) /*: ParseQuery*/{\n      return this._addCondition(key, '$gt', value);\n    }\n\n    /**\n     * Adds a constraint to the query that requires a particular key's value to\n     * be less than or equal to the provided value.\n     *\n     * @param {string} key The key to check.\n     * @param value The value that provides an upper bound.\n     * @returns {Parse.Query} Returns the query, so you can chain this call.\n     */\n  }, {\n    key: \"lessThanOrEqualTo\",\n    value: function (key /*: string*/, value /*: mixed*/) /*: ParseQuery*/{\n      return this._addCondition(key, '$lte', value);\n    }\n\n    /**\n     * Adds a constraint to the query that requires a particular key's value to\n     * be greater than or equal to the provided value.\n     *\n     * @param {string} key The key to check.\n     * @param {*} value The value that provides an lower bound.\n     * @returns {Parse.Query} Returns the query, so you can chain this call.\n     */\n  }, {\n    key: \"greaterThanOrEqualTo\",\n    value: function (key /*: string*/, value /*: mixed*/) /*: ParseQuery*/{\n      return this._addCondition(key, '$gte', value);\n    }\n\n    /**\n     * Adds a constraint to the query that requires a particular key's value to\n     * be contained in the provided list of values.\n     *\n     * @param {string} key The key to check.\n     * @param {Array<*>} value The values that will match.\n     * @returns {Parse.Query} Returns the query, so you can chain this call.\n     */\n  }, {\n    key: \"containedIn\",\n    value: function (key /*: string*/, value /*: Array<mixed>*/) /*: ParseQuery*/{\n      return this._addCondition(key, '$in', value);\n    }\n\n    /**\n     * Adds a constraint to the query that requires a particular key's value to\n     * not be contained in the provided list of values.\n     *\n     * @param {string} key The key to check.\n     * @param {Array<*>} value The values that will not match.\n     * @returns {Parse.Query} Returns the query, so you can chain this call.\n     */\n  }, {\n    key: \"notContainedIn\",\n    value: function (key /*: string*/, value /*: Array<mixed>*/) /*: ParseQuery*/{\n      return this._addCondition(key, '$nin', value);\n    }\n\n    /**\n     * Adds a constraint to the query that requires a particular key's value to\n     * be contained by the provided list of values. Get objects where all array elements match.\n     *\n     * @param {string} key The key to check.\n     * @param {Array} values The values that will match.\n     * @returns {Parse.Query} Returns the query, so you can chain this call.\n     */\n  }, {\n    key: \"containedBy\",\n    value: function (key /*: string*/, values /*: Array<mixed>*/) /*: ParseQuery*/{\n      return this._addCondition(key, '$containedBy', values);\n    }\n\n    /**\n     * Adds a constraint to the query that requires a particular key's value to\n     * contain each one of the provided list of values.\n     *\n     * @param {string} key The key to check.  This key's value must be an array.\n     * @param {Array} values The values that will match.\n     * @returns {Parse.Query} Returns the query, so you can chain this call.\n     */\n  }, {\n    key: \"containsAll\",\n    value: function (key /*: string*/, values /*: Array<mixed>*/) /*: ParseQuery*/{\n      return this._addCondition(key, '$all', values);\n    }\n\n    /**\n     * Adds a constraint to the query that requires a particular key's value to\n     * contain each one of the provided list of values starting with given strings.\n     *\n     * @param {string} key The key to check.  This key's value must be an array.\n     * @param {Array<string>} values The string values that will match as starting string.\n     * @returns {Parse.Query} Returns the query, so you can chain this call.\n     */\n  }, {\n    key: \"containsAllStartingWith\",\n    value: function (key /*: string*/, values /*: Array<string>*/) /*: ParseQuery*/{\n      var _this = this;\n      if (!(0, _isArray.default)(values)) {\n        values = [values];\n      }\n      var regexObject = (0, _map2.default)(values).call(values, function (value) {\n        return {\n          $regex: _this._regexStartWith(value)\n        };\n      });\n      return this.containsAll(key, regexObject);\n    }\n\n    /**\n     * Adds a constraint for finding objects that contain the given key.\n     *\n     * @param {string} key The key that should exist.\n     * @returns {Parse.Query} Returns the query, so you can chain this call.\n     */\n  }, {\n    key: \"exists\",\n    value: function (key /*: string*/) /*: ParseQuery*/{\n      return this._addCondition(key, '$exists', true);\n    }\n\n    /**\n     * Adds a constraint for finding objects that do not contain a given key.\n     *\n     * @param {string} key The key that should not exist\n     * @returns {Parse.Query} Returns the query, so you can chain this call.\n     */\n  }, {\n    key: \"doesNotExist\",\n    value: function (key /*: string*/) /*: ParseQuery*/{\n      return this._addCondition(key, '$exists', false);\n    }\n\n    /**\n     * Adds a regular expression constraint for finding string values that match\n     * the provided regular expression.\n     * This may be slow for large datasets.\n     *\n     * @param {string} key The key that the string to match is stored in.\n     * @param {RegExp} regex The regular expression pattern to match.\n     * @param {string} modifiers The regular expression mode.\n     * @returns {Parse.Query} Returns the query, so you can chain this call.\n     */\n  }, {\n    key: \"matches\",\n    value: function (key /*: string*/, regex /*: RegExp*/, modifiers /*: string*/) /*: ParseQuery*/{\n      this._addCondition(key, '$regex', regex);\n      if (!modifiers) {\n        modifiers = '';\n      }\n      if (regex.ignoreCase) {\n        modifiers += 'i';\n      }\n      if (regex.multiline) {\n        modifiers += 'm';\n      }\n      if (modifiers.length) {\n        this._addCondition(key, '$options', modifiers);\n      }\n      return this;\n    }\n\n    /**\n     * Adds a constraint that requires that a key's value matches a Parse.Query\n     * constraint.\n     *\n     * @param {string} key The key that the contains the object to match the\n     *                     query.\n     * @param {Parse.Query} query The query that should match.\n     * @returns {Parse.Query} Returns the query, so you can chain this call.\n     */\n  }, {\n    key: \"matchesQuery\",\n    value: function (key /*: string*/, query /*: ParseQuery*/) /*: ParseQuery*/{\n      var queryJSON = query.toJSON();\n      queryJSON.className = query.className;\n      return this._addCondition(key, '$inQuery', queryJSON);\n    }\n\n    /**\n     * Adds a constraint that requires that a key's value not matches a\n     * Parse.Query constraint.\n     *\n     * @param {string} key The key that the contains the object to match the\n     *                     query.\n     * @param {Parse.Query} query The query that should not match.\n     * @returns {Parse.Query} Returns the query, so you can chain this call.\n     */\n  }, {\n    key: \"doesNotMatchQuery\",\n    value: function (key /*: string*/, query /*: ParseQuery*/) /*: ParseQuery*/{\n      var queryJSON = query.toJSON();\n      queryJSON.className = query.className;\n      return this._addCondition(key, '$notInQuery', queryJSON);\n    }\n\n    /**\n     * Adds a constraint that requires that a key's value matches a value in\n     * an object returned by a different Parse.Query.\n     *\n     * @param {string} key The key that contains the value that is being\n     *                     matched.\n     * @param {string} queryKey The key in the objects returned by the query to\n     *                          match against.\n     * @param {Parse.Query} query The query to run.\n     * @returns {Parse.Query} Returns the query, so you can chain this call.\n     */\n  }, {\n    key: \"matchesKeyInQuery\",\n    value: function (key /*: string*/, queryKey /*: string*/, query /*: ParseQuery*/) /*: ParseQuery*/{\n      var queryJSON = query.toJSON();\n      queryJSON.className = query.className;\n      return this._addCondition(key, '$select', {\n        key: queryKey,\n        query: queryJSON\n      });\n    }\n\n    /**\n     * Adds a constraint that requires that a key's value not match a value in\n     * an object returned by a different Parse.Query.\n     *\n     * @param {string} key The key that contains the value that is being\n     *                     excluded.\n     * @param {string} queryKey The key in the objects returned by the query to\n     *                          match against.\n     * @param {Parse.Query} query The query to run.\n     * @returns {Parse.Query} Returns the query, so you can chain this call.\n     */\n  }, {\n    key: \"doesNotMatchKeyInQuery\",\n    value: function (key /*: string*/, queryKey /*: string*/, query /*: ParseQuery*/) /*: ParseQuery*/{\n      var queryJSON = query.toJSON();\n      queryJSON.className = query.className;\n      return this._addCondition(key, '$dontSelect', {\n        key: queryKey,\n        query: queryJSON\n      });\n    }\n\n    /**\n     * Adds a constraint for finding string values that contain a provided\n     * string.  This may be slow for large datasets.\n     *\n     * @param {string} key The key that the string to match is stored in.\n     * @param {string} substring The substring that the value must contain.\n     * @returns {Parse.Query} Returns the query, so you can chain this call.\n     */\n  }, {\n    key: \"contains\",\n    value: function (key /*: string*/, substring /*: string*/) /*: ParseQuery*/{\n      if (typeof substring !== 'string') {\n        throw new Error('The value being searched for must be a string.');\n      }\n      return this._addCondition(key, '$regex', quote(substring));\n    }\n\n    /**\n     * Adds a constraint for finding string values that contain a provided\n     * string. This may be slow for large datasets. Requires Parse-Server > 2.5.0\n     *\n     * In order to sort you must use select and ascending ($score is required)\n     *  <pre>\n     *   query.fullText('field', 'term');\n     *   query.ascending('$score');\n     *   query.select('$score');\n     *  </pre>\n     *\n     * To retrieve the weight / rank\n     *  <pre>\n     *   object->get('score');\n     *  </pre>\n     *\n     * You can define optionals by providing an object as a third parameter\n     *  <pre>\n     *   query.fullText('field', 'term', { language: 'es', diacriticSensitive: true });\n     *  </pre>\n     *\n     * @param {string} key The key that the string to match is stored in.\n     * @param {string} value The string to search\n     * @param {object} options (Optional)\n     * @param {string} options.language The language that determines the list of stop words for the search and the rules for the stemmer and tokenizer.\n     * @param {boolean} options.caseSensitive A boolean flag to enable or disable case sensitive search.\n     * @param {boolean} options.diacriticSensitive A boolean flag to enable or disable diacritic sensitive search.\n     * @returns {Parse.Query} Returns the query, so you can chain this call.\n     */\n  }, {\n    key: \"fullText\",\n    value: function (key /*: string*/, value /*: string*/, options /*: ?Object*/) /*: ParseQuery*/{\n      options = options || {};\n      if (!key) {\n        throw new Error('A key is required.');\n      }\n      if (!value) {\n        throw new Error('A search term is required');\n      }\n      if (typeof value !== 'string') {\n        throw new Error('The value being searched for must be a string.');\n      }\n      var fullOptions = {};\n      fullOptions.$term = value;\n      for (var option in options) {\n        switch (option) {\n          case 'language':\n            fullOptions.$language = options[option];\n            break;\n          case 'caseSensitive':\n            fullOptions.$caseSensitive = options[option];\n            break;\n          case 'diacriticSensitive':\n            fullOptions.$diacriticSensitive = options[option];\n            break;\n          default:\n            throw new Error(\"Unknown option: \".concat(option));\n        }\n      }\n      return this._addCondition(key, '$text', {\n        $search: fullOptions\n      });\n    }\n\n    /**\n     * Method to sort the full text search by text score\n     *\n     * @returns {Parse.Query} Returns the query, so you can chain this call.\n     */\n  }, {\n    key: \"sortByTextScore\",\n    value: function () {\n      this.ascending('$score');\n      this.select(['$score']);\n      return this;\n    }\n\n    /**\n     * Adds a constraint for finding string values that start with a provided\n     * string.  This query will use the backend index, so it will be fast even\n     * for large datasets.\n     *\n     * @param {string} key The key that the string to match is stored in.\n     * @param {string} prefix The substring that the value must start with.\n     * @param {string} modifiers The regular expression mode.\n     * @returns {Parse.Query} Returns the query, so you can chain this call.\n     */\n  }, {\n    key: \"startsWith\",\n    value: function (key /*: string*/, prefix /*: string*/, modifiers /*: string*/) /*: ParseQuery*/{\n      if (typeof prefix !== 'string') {\n        throw new Error('The value being searched for must be a string.');\n      }\n      return this.matches(key, this._regexStartWith(prefix), modifiers);\n    }\n\n    /**\n     * Adds a constraint for finding string values that end with a provided\n     * string.  This will be slow for large datasets.\n     *\n     * @param {string} key The key that the string to match is stored in.\n     * @param {string} suffix The substring that the value must end with.\n     * @param {string} modifiers The regular expression mode.\n     * @returns {Parse.Query} Returns the query, so you can chain this call.\n     */\n  }, {\n    key: \"endsWith\",\n    value: function (key /*: string*/, suffix /*: string*/, modifiers /*: string*/) /*: ParseQuery*/{\n      if (typeof suffix !== 'string') {\n        throw new Error('The value being searched for must be a string.');\n      }\n      return this.matches(key, quote(suffix) + '$', modifiers);\n    }\n\n    /**\n     * Adds a proximity based constraint for finding objects with key point\n     * values near the point given.\n     *\n     * @param {string} key The key that the Parse.GeoPoint is stored in.\n     * @param {Parse.GeoPoint} point The reference Parse.GeoPoint that is used.\n     * @returns {Parse.Query} Returns the query, so you can chain this call.\n     */\n  }, {\n    key: \"near\",\n    value: function (key /*: string*/, point /*: ParseGeoPoint*/) /*: ParseQuery*/{\n      if (!(point instanceof _ParseGeoPoint.default)) {\n        // Try to cast it as a GeoPoint\n        point = new _ParseGeoPoint.default(point);\n      }\n      return this._addCondition(key, '$nearSphere', point);\n    }\n\n    /**\n     * Adds a proximity based constraint for finding objects with key point\n     * values near the point given and within the maximum distance given.\n     *\n     * @param {string} key The key that the Parse.GeoPoint is stored in.\n     * @param {Parse.GeoPoint} point The reference Parse.GeoPoint that is used.\n     * @param {number} maxDistance Maximum distance (in radians) of results to return.\n     * @param {boolean} sorted A Bool value that is true if results should be\n     * sorted by distance ascending, false is no sorting is required,\n     * defaults to true.\n     * @returns {Parse.Query} Returns the query, so you can chain this call.\n     */\n  }, {\n    key: \"withinRadians\",\n    value: function (key /*: string*/, point /*: ParseGeoPoint*/, maxDistance /*: number*/, sorted /*: boolean*/) /*: ParseQuery*/{\n      if (sorted || sorted === undefined) {\n        this.near(key, point);\n        return this._addCondition(key, '$maxDistance', maxDistance);\n      } else {\n        return this._addCondition(key, '$geoWithin', {\n          $centerSphere: [[point.longitude, point.latitude], maxDistance]\n        });\n      }\n    }\n\n    /**\n     * Adds a proximity based constraint for finding objects with key point\n     * values near the point given and within the maximum distance given.\n     * Radius of earth used is 3958.8 miles.\n     *\n     * @param {string} key The key that the Parse.GeoPoint is stored in.\n     * @param {Parse.GeoPoint} point The reference Parse.GeoPoint that is used.\n     * @param {number} maxDistance Maximum distance (in miles) of results to return.\n     * @param {boolean} sorted A Bool value that is true if results should be\n     * sorted by distance ascending, false is no sorting is required,\n     * defaults to true.\n     * @returns {Parse.Query} Returns the query, so you can chain this call.\n     */\n  }, {\n    key: \"withinMiles\",\n    value: function (key /*: string*/, point /*: ParseGeoPoint*/, maxDistance /*: number*/, sorted /*: boolean*/) /*: ParseQuery*/{\n      return this.withinRadians(key, point, maxDistance / 3958.8, sorted);\n    }\n\n    /**\n     * Adds a proximity based constraint for finding objects with key point\n     * values near the point given and within the maximum distance given.\n     * Radius of earth used is 6371.0 kilometers.\n     *\n     * @param {string} key The key that the Parse.GeoPoint is stored in.\n     * @param {Parse.GeoPoint} point The reference Parse.GeoPoint that is used.\n     * @param {number} maxDistance Maximum distance (in kilometers) of results to return.\n     * @param {boolean} sorted A Bool value that is true if results should be\n     * sorted by distance ascending, false is no sorting is required,\n     * defaults to true.\n     * @returns {Parse.Query} Returns the query, so you can chain this call.\n     */\n  }, {\n    key: \"withinKilometers\",\n    value: function (key /*: string*/, point /*: ParseGeoPoint*/, maxDistance /*: number*/, sorted /*: boolean*/) /*: ParseQuery*/{\n      return this.withinRadians(key, point, maxDistance / 6371.0, sorted);\n    }\n\n    /**\n     * Adds a constraint to the query that requires a particular key's\n     * coordinates be contained within a given rectangular geographic bounding\n     * box.\n     *\n     * @param {string} key The key to be constrained.\n     * @param {Parse.GeoPoint} southwest\n     *     The lower-left inclusive corner of the box.\n     * @param {Parse.GeoPoint} northeast\n     *     The upper-right inclusive corner of the box.\n     * @returns {Parse.Query} Returns the query, so you can chain this call.\n     */\n  }, {\n    key: \"withinGeoBox\",\n    value: function (key /*: string*/, southwest /*: ParseGeoPoint*/, northeast /*: ParseGeoPoint*/) /*: ParseQuery*/{\n      if (!(southwest instanceof _ParseGeoPoint.default)) {\n        southwest = new _ParseGeoPoint.default(southwest);\n      }\n      if (!(northeast instanceof _ParseGeoPoint.default)) {\n        northeast = new _ParseGeoPoint.default(northeast);\n      }\n      this._addCondition(key, '$within', {\n        $box: [southwest, northeast]\n      });\n      return this;\n    }\n\n    /**\n     * Adds a constraint to the query that requires a particular key's\n     * coordinates be contained within and on the bounds of a given polygon.\n     * Supports closed and open (last point is connected to first) paths\n     *\n     * Polygon must have at least 3 points\n     *\n     * @param {string} key The key to be constrained.\n     * @param {Array} points Array of Coordinates / GeoPoints\n     * @returns {Parse.Query} Returns the query, so you can chain this call.\n     */\n  }, {\n    key: \"withinPolygon\",\n    value: function (key /*: string*/, points /*: Array<Array<number>>*/) /*: ParseQuery*/{\n      return this._addCondition(key, '$geoWithin', {\n        $polygon: points\n      });\n    }\n\n    /**\n     * Add a constraint to the query that requires a particular key's\n     * coordinates that contains a ParseGeoPoint\n     *\n     * @param {string} key The key to be constrained.\n     * @param {Parse.GeoPoint} point\n     * @returns {Parse.Query} Returns the query, so you can chain this call.\n     */\n  }, {\n    key: \"polygonContains\",\n    value: function (key /*: string*/, point /*: ParseGeoPoint*/) /*: ParseQuery*/{\n      return this._addCondition(key, '$geoIntersects', {\n        $point: point\n      });\n    }\n\n    /* Query Orderings */\n\n    /**\n     * Sorts the results in ascending order by the given key.\n     *\n     * @param {(string|string[])} keys The key to order by, which is a\n     * string of comma separated values, or an Array of keys, or multiple keys.\n     * @returns {Parse.Query} Returns the query, so you can chain this call.\n     */\n  }, {\n    key: \"ascending\",\n    value: function () /*: ParseQuery*/{\n      this._order = [];\n      for (var _len = arguments.length, keys = new Array(_len), _key5 = 0; _key5 < _len; _key5++) {\n        keys[_key5] = arguments[_key5];\n      }\n      return this.addAscending.apply(this, keys);\n    }\n\n    /**\n     * Sorts the results in ascending order by the given key,\n     * but can also add secondary sort descriptors without overwriting _order.\n     *\n     * @param {(string|string[])} keys The key to order by, which is a\n     * string of comma separated values, or an Array of keys, or multiple keys.\n     * @returns {Parse.Query} Returns the query, so you can chain this call.\n     */\n  }, {\n    key: \"addAscending\",\n    value: function () /*: ParseQuery*/{\n      var _this9 = this;\n      if (!this._order) {\n        this._order = [];\n      }\n      for (var _len2 = arguments.length, keys = new Array(_len2), _key6 = 0; _key6 < _len2; _key6++) {\n        keys[_key6] = arguments[_key6];\n      }\n      (0, _forEach.default)(keys).call(keys, function (key) {\n        var _context16;\n        if ((0, _isArray.default)(key)) {\n          key = key.join();\n        }\n        _this9._order = (0, _concat.default)(_context16 = _this9._order).call(_context16, key.replace(/\\s/g, '').split(','));\n      });\n      return this;\n    }\n\n    /**\n     * Sorts the results in descending order by the given key.\n     *\n     * @param {(string|string[])} keys The key to order by, which is a\n     * string of comma separated values, or an Array of keys, or multiple keys.\n     * @returns {Parse.Query} Returns the query, so you can chain this call.\n     */\n  }, {\n    key: \"descending\",\n    value: function () /*: ParseQuery*/{\n      this._order = [];\n      for (var _len3 = arguments.length, keys = new Array(_len3), _key7 = 0; _key7 < _len3; _key7++) {\n        keys[_key7] = arguments[_key7];\n      }\n      return this.addDescending.apply(this, keys);\n    }\n\n    /**\n     * Sorts the results in descending order by the given key,\n     * but can also add secondary sort descriptors without overwriting _order.\n     *\n     * @param {(string|string[])} keys The key to order by, which is a\n     * string of comma separated values, or an Array of keys, or multiple keys.\n     * @returns {Parse.Query} Returns the query, so you can chain this call.\n     */\n  }, {\n    key: \"addDescending\",\n    value: function () /*: ParseQuery*/{\n      var _this10 = this;\n      if (!this._order) {\n        this._order = [];\n      }\n      for (var _len4 = arguments.length, keys = new Array(_len4), _key8 = 0; _key8 < _len4; _key8++) {\n        keys[_key8] = arguments[_key8];\n      }\n      (0, _forEach.default)(keys).call(keys, function (key) {\n        var _context17, _context18;\n        if ((0, _isArray.default)(key)) {\n          key = key.join();\n        }\n        _this10._order = (0, _concat.default)(_context17 = _this10._order).call(_context17, (0, _map2.default)(_context18 = key.replace(/\\s/g, '').split(',')).call(_context18, function (k) {\n          return '-' + k;\n        }));\n      });\n      return this;\n    }\n\n    /* Query Options */\n\n    /**\n     * Sets the number of results to skip before returning any results.\n     * This is useful for pagination.\n     * Default is to skip zero results.\n     *\n     * @param {number} n the number of results to skip.\n     * @returns {Parse.Query} Returns the query, so you can chain this call.\n     */\n  }, {\n    key: \"skip\",\n    value: function (n /*: number*/) /*: ParseQuery*/{\n      if (typeof n !== 'number' || n < 0) {\n        throw new Error('You can only skip by a positive number');\n      }\n      this._skip = n;\n      return this;\n    }\n\n    /**\n     * Sets the limit of the number of results to return. The default limit is 100.\n     *\n     * @param {number} n the number of results to limit to.\n     * @returns {Parse.Query} Returns the query, so you can chain this call.\n     */\n  }, {\n    key: \"limit\",\n    value: function (n /*: number*/) /*: ParseQuery*/{\n      if (typeof n !== 'number') {\n        throw new Error('You can only set the limit to a numeric value');\n      }\n      this._limit = n;\n      return this;\n    }\n\n    /**\n     * Sets the flag to include with response the total number of objects satisfying this query,\n     * despite limits/skip. Might be useful for pagination.\n     * Note that result of this query will be wrapped as an object with\n     * `results`: holding {ParseObject} array and `count`: integer holding total number\n     *\n     * @param {boolean} includeCount false - disable, true - enable.\n     * @returns {Parse.Query} Returns the query, so you can chain this call.\n     */\n  }, {\n    key: \"withCount\",\n    value: function () /*: ParseQuery*/{\n      var includeCount /*: boolean*/ = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : true;\n      if (typeof includeCount !== 'boolean') {\n        throw new Error('You can only set withCount to a boolean value');\n      }\n      this._count = includeCount;\n      return this;\n    }\n    /**\n     * Includes nested Parse.Objects for the provided key.  You can use dot\n     * notation to specify which fields in the included object are also fetched.\n     *\n     * You can include all nested Parse.Objects by passing in '*'.\n     * Requires Parse Server 3.0.0+\n     * <pre>query.include('*');</pre>\n     *\n     * @param {...string|Array<string>} keys The name(s) of the key(s) to include.\n     * @returns {Parse.Query} Returns the query, so you can chain this call.\n     */\n  }, {\n    key: \"include\",\n    value: function () /*: ParseQuery*/{\n      var _this11 = this;\n      for (var _len5 = arguments.length, keys = new Array(_len5), _key9 = 0; _key9 < _len5; _key9++) {\n        keys[_key9] = arguments[_key9];\n      }\n      (0, _forEach.default)(keys).call(keys, function (key) {\n        if ((0, _isArray.default)(key)) {\n          var _context19;\n          _this11._include = (0, _concat.default)(_context19 = _this11._include).call(_context19, key);\n        } else {\n          _this11._include.push(key);\n        }\n      });\n      return this;\n    }\n\n    /**\n     * Includes all nested Parse.Objects one level deep.\n     *\n     * Requires Parse Server 3.0.0+\n     *\n     * @returns {Parse.Query} Returns the query, so you can chain this call.\n     */\n  }, {\n    key: \"includeAll\",\n    value: function () /*: ParseQuery*/{\n      return this.include('*');\n    }\n\n    /**\n     * Restricts the fields of the returned Parse.Objects to include only the\n     * provided keys.  If this is called multiple times, then all of the keys\n     * specified in each of the calls will be included.\n     *\n     * @param {...string|Array<string>} keys The name(s) of the key(s) to include.\n     * @returns {Parse.Query} Returns the query, so you can chain this call.\n     */\n  }, {\n    key: \"select\",\n    value: function () /*: ParseQuery*/{\n      var _this12 = this;\n      if (!this._select) {\n        this._select = [];\n      }\n      for (var _len6 = arguments.length, keys = new Array(_len6), _key10 = 0; _key10 < _len6; _key10++) {\n        keys[_key10] = arguments[_key10];\n      }\n      (0, _forEach.default)(keys).call(keys, function (key) {\n        if ((0, _isArray.default)(key)) {\n          var _context20;\n          _this12._select = (0, _concat.default)(_context20 = _this12._select).call(_context20, key);\n        } else {\n          _this12._select.push(key);\n        }\n      });\n      return this;\n    }\n\n    /**\n     * Restricts the fields of the returned Parse.Objects to all keys except the\n     * provided keys. Exclude takes precedence over select and include.\n     *\n     * Requires Parse Server 3.6.0+\n     *\n     * @param {...string|Array<string>} keys The name(s) of the key(s) to exclude.\n     * @returns {Parse.Query} Returns the query, so you can chain this call.\n     */\n  }, {\n    key: \"exclude\",\n    value: function () /*: ParseQuery*/{\n      var _this13 = this;\n      for (var _len7 = arguments.length, keys = new Array(_len7), _key11 = 0; _key11 < _len7; _key11++) {\n        keys[_key11] = arguments[_key11];\n      }\n      (0, _forEach.default)(keys).call(keys, function (key) {\n        if ((0, _isArray.default)(key)) {\n          var _context21;\n          _this13._exclude = (0, _concat.default)(_context21 = _this13._exclude).call(_context21, key);\n        } else {\n          _this13._exclude.push(key);\n        }\n      });\n      return this;\n    }\n\n    /**\n     * Restricts live query to trigger only for watched fields.\n     *\n     * Requires Parse Server 6.0.0+\n     *\n     * @param {...string|Array<string>} keys The name(s) of the key(s) to watch.\n     * @returns {Parse.Query} Returns the query, so you can chain this call.\n     */\n  }, {\n    key: \"watch\",\n    value: function () /*: ParseQuery*/{\n      var _this14 = this;\n      for (var _len8 = arguments.length, keys = new Array(_len8), _key12 = 0; _key12 < _len8; _key12++) {\n        keys[_key12] = arguments[_key12];\n      }\n      (0, _forEach.default)(keys).call(keys, function (key) {\n        if ((0, _isArray.default)(key)) {\n          var _context22;\n          _this14._watch = (0, _concat.default)(_context22 = _this14._watch).call(_context22, key);\n        } else {\n          _this14._watch.push(key);\n        }\n      });\n      return this;\n    }\n\n    /**\n     * Changes the read preference that the backend will use when performing the query to the database.\n     *\n     * @param {string} readPreference The read preference for the main query.\n     * @param {string} includeReadPreference The read preference for the queries to include pointers.\n     * @param {string} subqueryReadPreference The read preference for the sub queries.\n     * @returns {Parse.Query} Returns the query, so you can chain this call.\n     */\n  }, {\n    key: \"readPreference\",\n    value: function (_readPreference /*: string*/, includeReadPreference /*:: ?: string*/, subqueryReadPreference /*:: ?: string*/) /*: ParseQuery*/{\n      this._readPreference = _readPreference;\n      this._includeReadPreference = includeReadPreference;\n      this._subqueryReadPreference = subqueryReadPreference;\n      return this;\n    }\n\n    /**\n     * Subscribe this query to get liveQuery updates\n     *\n     * @param {string} sessionToken (optional) Defaults to the currentUser\n     * @returns {Promise<LiveQuerySubscription>} Returns the liveQuerySubscription, it's an event emitter\n     * which can be used to get liveQuery updates.\n     */\n  }, {\n    key: \"subscribe\",\n    value: function () {\n      var _subscribe = (0, _asyncToGenerator2.default)( /*#__PURE__*/_regenerator.default.mark(function _callee7(sessionToken /*:: ?: string*/) {\n        var currentUser, liveQueryClient, subscription;\n        return _regenerator.default.wrap(function (_context23) {\n          while (1) switch (_context23.prev = _context23.next) {\n            case 0:\n              _context23.next = 2;\n              return _CoreManager.default.getUserController().currentUserAsync();\n            case 2:\n              currentUser = _context23.sent;\n              if (!sessionToken) {\n                sessionToken = currentUser ? currentUser.getSessionToken() : undefined;\n              }\n              _context23.next = 6;\n              return _CoreManager.default.getLiveQueryController().getDefaultLiveQueryClient();\n            case 6:\n              liveQueryClient = _context23.sent;\n              if (liveQueryClient.shouldOpen()) {\n                liveQueryClient.open();\n              }\n              subscription = liveQueryClient.subscribe(this, sessionToken);\n              return _context23.abrupt(\"return\", subscription.subscribePromise.then(function () {\n                return subscription;\n              }));\n            case 10:\n            case \"end\":\n              return _context23.stop();\n          }\n        }, _callee7, this);\n      }));\n      function subscribe() {\n        return _subscribe.apply(this, arguments);\n      }\n      return subscribe;\n    }()\n    /**\n     * Constructs a Parse.Query that is the OR of the passed in queries.  For\n     * example:\n     * <pre>var compoundQuery = Parse.Query.or(query1, query2, query3);</pre>\n     *\n     * will create a compoundQuery that is an or of the query1, query2, and\n     * query3.\n     *\n     * @param {...Parse.Query} queries The list of queries to OR.\n     * @static\n     * @returns {Parse.Query} The query that is the OR of the passed in queries.\n     */\n  }, {\n    key: \"fromNetwork\",\n    value:\n    /**\n     * Change the source of this query to the server.\n     *\n     * @returns {Parse.Query} Returns the query, so you can chain this call.\n     */\n    function () /*: ParseQuery*/{\n      this._queriesLocalDatastore = false;\n      this._localDatastorePinName = null;\n      return this;\n    }\n\n    /**\n     * Changes the source of this query to all pinned objects.\n     *\n     * @returns {Parse.Query} Returns the query, so you can chain this call.\n     */\n  }, {\n    key: \"fromLocalDatastore\",\n    value: function () /*: ParseQuery*/{\n      return this.fromPinWithName(null);\n    }\n\n    /**\n     * Changes the source of this query to the default group of pinned objects.\n     *\n     * @returns {Parse.Query} Returns the query, so you can chain this call.\n     */\n  }, {\n    key: \"fromPin\",\n    value: function () /*: ParseQuery*/{\n      return this.fromPinWithName(_LocalDatastoreUtils.DEFAULT_PIN);\n    }\n\n    /**\n     * Changes the source of this query to a specific group of pinned objects.\n     *\n     * @param {string} name The name of query source.\n     * @returns {Parse.Query} Returns the query, so you can chain this call.\n     */\n  }, {\n    key: \"fromPinWithName\",\n    value: function (name /*:: ?: string*/) /*: ParseQuery*/{\n      var localDatastore = _CoreManager.default.getLocalDatastore();\n      if (localDatastore.checkIfEnabled()) {\n        this._queriesLocalDatastore = true;\n        this._localDatastorePinName = name;\n      }\n      return this;\n    }\n\n    /**\n     * Cancels the current network request (if any is running).\n     *\n     * @returns {Parse.Query} Returns the query, so you can chain this call.\n     */\n  }, {\n    key: \"cancel\",\n    value: function () /*: ParseQuery*/{\n      var _this15 = this;\n      if (this._xhrRequest.task && typeof this._xhrRequest.task.abort === 'function') {\n        this._xhrRequest.task._aborted = true;\n        this._xhrRequest.task.abort();\n        this._xhrRequest.task = null;\n        this._xhrRequest.onchange = function () {};\n        return this;\n      }\n      return this._xhrRequest.onchange = function () {\n        return _this15.cancel();\n      };\n    }\n  }, {\n    key: \"_setRequestTask\",\n    value: function (options) {\n      var _this16 = this;\n      options.requestTask = function (task) {\n        _this16._xhrRequest.task = task;\n        _this16._xhrRequest.onchange();\n      };\n    }\n  }], [{\n    key: \"fromJSON\",\n    value: function (className /*: string*/, json /*: QueryJSON*/) /*: ParseQuery*/{\n      var query = new ParseQuery(className);\n      return query.withJSON(json);\n    }\n  }, {\n    key: \"or\",\n    value: function () /*: ParseQuery*/{\n      for (var _len9 = arguments.length, queries = new Array(_len9), _key13 = 0; _key13 < _len9; _key13++) {\n        queries[_key13] = arguments[_key13];\n      }\n      var className = _getClassNameFromQueries(queries);\n      var query = new ParseQuery(className);\n      query._orQuery(queries);\n      return query;\n    }\n\n    /**\n     * Constructs a Parse.Query that is the AND of the passed in queries.  For\n     * example:\n     * <pre>var compoundQuery = Parse.Query.and(query1, query2, query3);</pre>\n     *\n     * will create a compoundQuery that is an and of the query1, query2, and\n     * query3.\n     *\n     * @param {...Parse.Query} queries The list of queries to AND.\n     * @static\n     * @returns {Parse.Query} The query that is the AND of the passed in queries.\n     */\n  }, {\n    key: \"and\",\n    value: function () /*: ParseQuery*/{\n      for (var _len10 = arguments.length, queries = new Array(_len10), _key14 = 0; _key14 < _len10; _key14++) {\n        queries[_key14] = arguments[_key14];\n      }\n      var className = _getClassNameFromQueries(queries);\n      var query = new ParseQuery(className);\n      query._andQuery(queries);\n      return query;\n    }\n\n    /**\n     * Constructs a Parse.Query that is the NOR of the passed in queries.  For\n     * example:\n     * <pre>const compoundQuery = Parse.Query.nor(query1, query2, query3);</pre>\n     *\n     * will create a compoundQuery that is a nor of the query1, query2, and\n     * query3.\n     *\n     * @param {...Parse.Query} queries The list of queries to NOR.\n     * @static\n     * @returns {Parse.Query} The query that is the NOR of the passed in queries.\n     */\n  }, {\n    key: \"nor\",\n    value: function () /*: ParseQuery*/{\n      for (var _len11 = arguments.length, queries = new Array(_len11), _key15 = 0; _key15 < _len11; _key15++) {\n        queries[_key15] = arguments[_key15];\n      }\n      var className = _getClassNameFromQueries(queries);\n      var query = new ParseQuery(className);\n      query._norQuery(queries);\n      return query;\n    }\n  }]);\n  return ParseQuery;\n}();\nvar DefaultController = {\n  find: function (className /*: string*/, params /*: QueryJSON*/, options /*: RequestOptions*/) /*: Promise<Array<ParseObject>>*/{\n    var RESTController = _CoreManager.default.getRESTController();\n    return RESTController.request('GET', 'classes/' + className, params, options);\n  },\n  aggregate: function (className /*: string*/, params /*: any*/, options /*: RequestOptions*/) /*: Promise<Array<mixed>>*/{\n    var RESTController = _CoreManager.default.getRESTController();\n    return RESTController.request('GET', 'aggregate/' + className, params, options);\n  }\n};\n_CoreManager.default.setQueryController(DefaultController);\nvar _default = ParseQuery;\nexports.default = _default;","map":{"version":3,"names":["_Object$defineProperty","require","_interopRequireDefault","exports","value","default","_regenerator","_slicedToArray2","_toConsumableArray2","_asyncToGenerator2","_classCallCheck2","_createClass2","_defineProperty2","_typeof2","_forEach","_indexOf","_keys","_slice","_map2","_filter2","_keys2","_concat","_includes","_sort","_splice","_promise","_find","_isArray","_entries","_CoreManager","_encode","_promiseUtils","_ParseError","_ParseGeoPoint","_ParseObject","_OfflineQuery","_LocalDatastoreUtils","quote","s","replace","_getClassNameFromQueries","queries","className","call","q","Error","handleSelectResult","data","select","serverDataMask","field","hasSubObjectSelect","hasOwnProperty","undefined","pathComponents","split","_obj","serverMask","component","index","arr","length","serverData","getObjectStateController","getServerData","id","objectId","copyMissingDataWithMask","src","dest","mask","copyThisLevel","_key","_key2","handleOfflineSort","a","b","sorts","order","operator","isDescending","substring","test","INVALID_KEY_NAME","concat","field1","get","field2","remainingSorts","ParseQuery","objectClass","_obj2","TypeError","_where","_watch","_include","_exclude","_count","_limit","_skip","_readPreference","_includeReadPreference","_subqueryReadPreference","_queriesLocalDatastore","_localDatastorePinName","_extraOptions","_xhrRequest","task","onchange","key","queryJSON","toJSON","where","$or","$and","$nor","condition","string","_handleOfflineQuery2","mark","_callee","params","_context","_this2","localDatastore","objects","results","keys","alwaysSelectedKeys","count","limit","wrap","_context3","prev","next","validateQuery","getLocalDatastore","_serializeObjectsFromPinName","sent","json","object","fromJSON","_localId","matchesQuery","_context2","_toFullJSON","skip","abrupt","stop","_handleOfflineQuery","apply","arguments","watch","join","include","excludeKeys","_select","_order","readPreference","includeReadPreference","subqueryReadPreference","_hint","hint","_explain","explain","_key3","_key4","_context4","options","equalTo","firstOptions","useMasterKey","sessionToken","context","first","then","response","errorObject","OBJECT_NOT_FOUND","reject","_this3","findOptions","_setRequestTask","controller","getQueryController","_context5","override","_findAll","_callee2","result","_context7","eachBatch","_context6","findAll","distinctOptions","distinct","aggregate","pipeline","aggregateOptions","unshift","$match","_this4","callback","_context8","query","batchSize","i","_context9","_attr","val","v","conditionMap","cond","ascending","finished","previousResults","continueWhile","_callee3","_yield$Promise$all","_yield$Promise$all2","_context10","all","resolve","greaterThan","callbacksDone","_map","_callee4","_this5","array","_context11","each","push","map","_reduce","_callee5","initialValue","accumulator","_context12","reduce","_filter","_callee6","_this6","_context13","flag","filter","_this7","_context14","_ref2","_ref3","k","doesNotExist","_this8","_context15","_ref4","_ref5","notEqualTo","_addCondition","values","_this","regexObject","$regex","_regexStartWith","containsAll","regex","modifiers","ignoreCase","multiline","queryKey","fullOptions","$term","option","$language","$caseSensitive","$diacriticSensitive","$search","prefix","matches","suffix","point","maxDistance","sorted","near","$centerSphere","longitude","latitude","withinRadians","southwest","northeast","$box","points","$polygon","$point","_len","Array","_key5","addAscending","_this9","_len2","_key6","_context16","_len3","_key7","addDescending","_this10","_len4","_key8","_context17","_context18","n","includeCount","_this11","_len5","_key9","_context19","_this12","_len6","_key10","_context20","_this13","_len7","_key11","_context21","_this14","_len8","_key12","_context22","_subscribe","_callee7","currentUser","liveQueryClient","subscription","_context23","getUserController","currentUserAsync","getSessionToken","getLiveQueryController","getDefaultLiveQueryClient","shouldOpen","open","subscribe","subscribePromise","fromPinWithName","DEFAULT_PIN","name","checkIfEnabled","_this15","abort","_aborted","cancel","_this16","requestTask","withJSON","_len9","_key13","_orQuery","_len10","_key14","_andQuery","_len11","_key15","_norQuery","DefaultController","find","RESTController","getRESTController","request","setQueryController","_default"],"sources":["/home/mspadafo/compsci/MWD/mwd-pogg/poggcopy/pogg/node_modules/parse/lib/browser/ParseQuery.js"],"sourcesContent":["\"use strict\";\n\nvar _Object$defineProperty = require(\"@babel/runtime-corejs3/core-js-stable/object/define-property\");\nvar _interopRequireDefault = require(\"@babel/runtime-corejs3/helpers/interopRequireDefault\");\n_Object$defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.default = void 0;\nvar _regenerator = _interopRequireDefault(require(\"@babel/runtime-corejs3/regenerator\"));\nvar _slicedToArray2 = _interopRequireDefault(require(\"@babel/runtime-corejs3/helpers/slicedToArray\"));\nvar _toConsumableArray2 = _interopRequireDefault(require(\"@babel/runtime-corejs3/helpers/toConsumableArray\"));\nvar _asyncToGenerator2 = _interopRequireDefault(require(\"@babel/runtime-corejs3/helpers/asyncToGenerator\"));\nvar _classCallCheck2 = _interopRequireDefault(require(\"@babel/runtime-corejs3/helpers/classCallCheck\"));\nvar _createClass2 = _interopRequireDefault(require(\"@babel/runtime-corejs3/helpers/createClass\"));\nvar _defineProperty2 = _interopRequireDefault(require(\"@babel/runtime-corejs3/helpers/defineProperty\"));\nvar _typeof2 = _interopRequireDefault(require(\"@babel/runtime-corejs3/helpers/typeof\"));\nvar _forEach = _interopRequireDefault(require(\"@babel/runtime-corejs3/core-js-stable/instance/for-each\"));\nvar _indexOf = _interopRequireDefault(require(\"@babel/runtime-corejs3/core-js-stable/instance/index-of\"));\nvar _keys = _interopRequireDefault(require(\"@babel/runtime-corejs3/core-js-stable/object/keys\"));\nvar _slice = _interopRequireDefault(require(\"@babel/runtime-corejs3/core-js-stable/instance/slice\"));\nvar _map2 = _interopRequireDefault(require(\"@babel/runtime-corejs3/core-js-stable/instance/map\"));\nvar _filter2 = _interopRequireDefault(require(\"@babel/runtime-corejs3/core-js-stable/instance/filter\"));\nvar _keys2 = _interopRequireDefault(require(\"@babel/runtime-corejs3/core-js-stable/instance/keys\"));\nvar _concat = _interopRequireDefault(require(\"@babel/runtime-corejs3/core-js-stable/instance/concat\"));\nvar _includes = _interopRequireDefault(require(\"@babel/runtime-corejs3/core-js-stable/instance/includes\"));\nvar _sort = _interopRequireDefault(require(\"@babel/runtime-corejs3/core-js-stable/instance/sort\"));\nvar _splice = _interopRequireDefault(require(\"@babel/runtime-corejs3/core-js-stable/instance/splice\"));\nvar _promise = _interopRequireDefault(require(\"@babel/runtime-corejs3/core-js-stable/promise\"));\nvar _find = _interopRequireDefault(require(\"@babel/runtime-corejs3/core-js-stable/instance/find\"));\nvar _isArray = _interopRequireDefault(require(\"@babel/runtime-corejs3/core-js-stable/array/is-array\"));\nvar _entries = _interopRequireDefault(require(\"@babel/runtime-corejs3/core-js-stable/object/entries\"));\nvar _CoreManager = _interopRequireDefault(require(\"./CoreManager\"));\nvar _encode = _interopRequireDefault(require(\"./encode\"));\nvar _promiseUtils = require(\"./promiseUtils\");\nvar _ParseError = _interopRequireDefault(require(\"./ParseError\"));\nvar _ParseGeoPoint = _interopRequireDefault(require(\"./ParseGeoPoint\"));\nvar _ParseObject = _interopRequireDefault(require(\"./ParseObject\"));\nvar _OfflineQuery = _interopRequireDefault(require(\"./OfflineQuery\"));\nvar _LocalDatastoreUtils = require(\"./LocalDatastoreUtils\");\n/*\n * @flow\n */\n/*:: import type LiveQuerySubscription from './LiveQuerySubscription';*/\n/*:: import type { RequestOptions, FullOptions } from './RESTController';*/\n/*:: type BatchOptions = FullOptions & { batchSize?: number };*/\n/*:: export type WhereClause = {\n  [attr: string]: mixed,\n};*/\n/*:: export type QueryJSON = {\n  where: WhereClause,\n  watch?: string,\n  include?: string,\n  excludeKeys?: string,\n  keys?: string,\n  limit?: number,\n  skip?: number,\n  order?: string,\n  className?: string,\n  count?: number,\n  hint?: mixed,\n  explain?: boolean,\n  readPreference?: string,\n  includeReadPreference?: string,\n  subqueryReadPreference?: string,\n};*/\n/**\n * Converts a string into a regex that matches it.\n * Surrounding with \\Q .. \\E does this, we just need to escape any \\E's in\n * the text separately.\n *\n * @param s\n * @private\n * @returns {string}\n */\nfunction quote(s /*: string*/) /*: string*/{\n  return '\\\\Q' + s.replace('\\\\E', '\\\\E\\\\\\\\E\\\\Q') + '\\\\E';\n}\n\n/**\n * Extracts the class name from queries. If not all queries have the same\n * class name an error will be thrown.\n *\n * @param queries\n * @private\n * @returns {string}\n */\nfunction _getClassNameFromQueries(queries /*: Array<ParseQuery>*/) /*: ?string*/{\n  var className = null;\n  (0, _forEach.default)(queries).call(queries, function (q) {\n    if (!className) {\n      className = q.className;\n    }\n    if (className !== q.className) {\n      throw new Error('All queries must be for the same class.');\n    }\n  });\n  return className;\n}\n\n/*\n * Handles pre-populating the result data of a query with select fields,\n * making sure that the data object contains keys for all objects that have\n * been requested with a select, so that our cached state updates correctly.\n */\nfunction handleSelectResult(data /*: any*/, select /*: Array<string>*/) {\n  var serverDataMask = {};\n  (0, _forEach.default)(select).call(select, function (field) {\n    var hasSubObjectSelect = (0, _indexOf.default)(field).call(field, '.') !== -1;\n    if (!hasSubObjectSelect && !data.hasOwnProperty(field)) {\n      // this field was selected, but is missing from the retrieved data\n      data[field] = undefined;\n    } else if (hasSubObjectSelect) {\n      // this field references a sub-object,\n      // so we need to walk down the path components\n      var pathComponents = field.split('.');\n      var _obj = data;\n      var serverMask = serverDataMask;\n      (0, _forEach.default)(pathComponents).call(pathComponents, function (component, index, arr) {\n        // add keys if the expected data is missing\n        if (_obj && !_obj.hasOwnProperty(component)) {\n          _obj[component] = undefined;\n        }\n        if (_obj && (0, _typeof2.default)(_obj) === 'object') {\n          _obj = _obj[component];\n        }\n\n        //add this path component to the server mask so we can fill it in later if needed\n        if (index < arr.length - 1) {\n          if (!serverMask[component]) {\n            serverMask[component] = {};\n          }\n          serverMask = serverMask[component];\n        }\n      });\n    }\n  });\n  if ((0, _keys.default)(serverDataMask).length > 0) {\n    // When selecting from sub-objects, we don't want to blow away the missing\n    // information that we may have retrieved before. We've already added any\n    // missing selected keys to sub-objects, but we still need to add in the\n    // data for any previously retrieved sub-objects that were not selected.\n\n    var serverData = _CoreManager.default.getObjectStateController().getServerData({\n      id: data.objectId,\n      className: data.className\n    });\n    copyMissingDataWithMask(serverData, data, serverDataMask, false);\n  }\n}\nfunction copyMissingDataWithMask(src, dest, mask, copyThisLevel) {\n  //copy missing elements at this level\n  if (copyThisLevel) {\n    for (var _key in src) {\n      if (src.hasOwnProperty(_key) && !dest.hasOwnProperty(_key)) {\n        dest[_key] = src[_key];\n      }\n    }\n  }\n  for (var _key2 in mask) {\n    if (dest[_key2] !== undefined && dest[_key2] !== null && src !== undefined && src !== null) {\n      //traverse into objects as needed\n      copyMissingDataWithMask(src[_key2], dest[_key2], mask[_key2], true);\n    }\n  }\n}\nfunction handleOfflineSort(a, b, sorts) {\n  var order = sorts[0];\n  var operator = (0, _slice.default)(order).call(order, 0, 1);\n  var isDescending = operator === '-';\n  if (isDescending) {\n    order = order.substring(1);\n  }\n  if (order === '_created_at') {\n    order = 'createdAt';\n  }\n  if (order === '_updated_at') {\n    order = 'updatedAt';\n  }\n  if (!/^[A-Za-z][0-9A-Za-z_]*$/.test(order) || order === 'password') {\n    throw new _ParseError.default(_ParseError.default.INVALID_KEY_NAME, \"Invalid Key: \".concat(order));\n  }\n  var field1 = a.get(order);\n  var field2 = b.get(order);\n  if (field1 < field2) {\n    return isDescending ? 1 : -1;\n  }\n  if (field1 > field2) {\n    return isDescending ? -1 : 1;\n  }\n  if (sorts.length > 1) {\n    var remainingSorts = (0, _slice.default)(sorts).call(sorts, 1);\n    return handleOfflineSort(a, b, remainingSorts);\n  }\n  return 0;\n}\n/**\n * Creates a new parse Parse.Query for the given Parse.Object subclass.\n *\n * <p>Parse.Query defines a query that is used to fetch Parse.Objects. The\n * most common use case is finding all objects that match a query through the\n * <code>find</code> method. for example, this sample code fetches all objects\n * of class <code>myclass</code>. it calls a different function depending on\n * whether the fetch succeeded or not.\n *\n * <pre>\n * var query = new Parse.Query(myclass);\n * query.find().then((results) => {\n *   // results is an array of parse.object.\n * }).catch((error) =>  {\n *  // error is an instance of parse.error.\n * });</pre></p>\n *\n * <p>a Parse.Query can also be used to retrieve a single object whose id is\n * known, through the get method. for example, this sample code fetches an\n * object of class <code>myclass</code> and id <code>myid</code>. it calls a\n * different function depending on whether the fetch succeeded or not.\n *\n * <pre>\n * var query = new Parse.Query(myclass);\n * query.get(myid).then((object) => {\n *     // object is an instance of parse.object.\n * }).catch((error) =>  {\n *  // error is an instance of parse.error.\n * });</pre></p>\n *\n * <p>a Parse.Query can also be used to count the number of objects that match\n * the query without retrieving all of those objects. for example, this\n * sample code counts the number of objects of the class <code>myclass</code>\n * <pre>\n * var query = new Parse.Query(myclass);\n * query.count().then((number) => {\n *     // there are number instances of myclass.\n * }).catch((error) => {\n *     // error is an instance of Parse.Error.\n * });</pre></p>\n *\n * @alias Parse.Query\n */\nvar ParseQuery = /*#__PURE__*/function () {\n  /**\n   * @param {(string | Parse.Object)} objectClass An instance of a subclass of Parse.Object, or a Parse className string.\n   */\n  function ParseQuery(objectClass /*: string | ParseObject*/) {\n    (0, _classCallCheck2.default)(this, ParseQuery);\n    /**\n     * @property {string} className\n     */\n    (0, _defineProperty2.default)(this, \"className\", void 0);\n    (0, _defineProperty2.default)(this, \"_where\", void 0);\n    (0, _defineProperty2.default)(this, \"_watch\", void 0);\n    (0, _defineProperty2.default)(this, \"_include\", void 0);\n    (0, _defineProperty2.default)(this, \"_exclude\", void 0);\n    (0, _defineProperty2.default)(this, \"_select\", void 0);\n    (0, _defineProperty2.default)(this, \"_limit\", void 0);\n    (0, _defineProperty2.default)(this, \"_skip\", void 0);\n    (0, _defineProperty2.default)(this, \"_count\", void 0);\n    (0, _defineProperty2.default)(this, \"_order\", void 0);\n    (0, _defineProperty2.default)(this, \"_readPreference\", void 0);\n    (0, _defineProperty2.default)(this, \"_includeReadPreference\", void 0);\n    (0, _defineProperty2.default)(this, \"_subqueryReadPreference\", void 0);\n    (0, _defineProperty2.default)(this, \"_queriesLocalDatastore\", void 0);\n    (0, _defineProperty2.default)(this, \"_localDatastorePinName\", void 0);\n    (0, _defineProperty2.default)(this, \"_extraOptions\", void 0);\n    (0, _defineProperty2.default)(this, \"_hint\", void 0);\n    (0, _defineProperty2.default)(this, \"_explain\", void 0);\n    (0, _defineProperty2.default)(this, \"_xhrRequest\", void 0);\n    if (typeof objectClass === 'string') {\n      if (objectClass === 'User' && _CoreManager.default.get('PERFORM_USER_REWRITE')) {\n        this.className = '_User';\n      } else {\n        this.className = objectClass;\n      }\n    } else if (objectClass instanceof _ParseObject.default) {\n      this.className = objectClass.className;\n    } else if (typeof objectClass === 'function') {\n      if (typeof objectClass.className === 'string') {\n        this.className = objectClass.className;\n      } else {\n        var _obj2 = new objectClass();\n        this.className = _obj2.className;\n      }\n    } else {\n      throw new TypeError('A ParseQuery must be constructed with a ParseObject or class name.');\n    }\n    this._where = {};\n    this._watch = [];\n    this._include = [];\n    this._exclude = [];\n    this._count = false;\n    this._limit = -1; // negative limit is not sent in the server request\n    this._skip = 0;\n    this._readPreference = null;\n    this._includeReadPreference = null;\n    this._subqueryReadPreference = null;\n    this._queriesLocalDatastore = false;\n    this._localDatastorePinName = null;\n    this._extraOptions = {};\n    this._xhrRequest = {\n      task: null,\n      onchange: function () {}\n    };\n  }\n\n  /**\n   * Adds constraint that at least one of the passed in queries matches.\n   *\n   * @param {Array} queries\n   * @returns {Parse.Query} Returns the query, so you can chain this call.\n   */\n  (0, _createClass2.default)(ParseQuery, [{\n    key: \"_orQuery\",\n    value: function (queries /*: Array<ParseQuery>*/) /*: ParseQuery*/{\n      var queryJSON = (0, _map2.default)(queries).call(queries, function (q) {\n        return q.toJSON().where;\n      });\n      this._where.$or = queryJSON;\n      return this;\n    }\n\n    /**\n     * Adds constraint that all of the passed in queries match.\n     *\n     * @param {Array} queries\n     * @returns {Parse.Query} Returns the query, so you can chain this call.\n     */\n  }, {\n    key: \"_andQuery\",\n    value: function (queries /*: Array<ParseQuery>*/) /*: ParseQuery*/{\n      var queryJSON = (0, _map2.default)(queries).call(queries, function (q) {\n        return q.toJSON().where;\n      });\n      this._where.$and = queryJSON;\n      return this;\n    }\n\n    /**\n     * Adds constraint that none of the passed in queries match.\n     *\n     * @param {Array} queries\n     * @returns {Parse.Query} Returns the query, so you can chain this call.\n     */\n  }, {\n    key: \"_norQuery\",\n    value: function (queries /*: Array<ParseQuery>*/) /*: ParseQuery*/{\n      var queryJSON = (0, _map2.default)(queries).call(queries, function (q) {\n        return q.toJSON().where;\n      });\n      this._where.$nor = queryJSON;\n      return this;\n    }\n\n    /**\n     * Helper for condition queries\n     *\n     * @param key\n     * @param condition\n     * @param value\n     * @returns {Parse.Query}\n     */\n  }, {\n    key: \"_addCondition\",\n    value: function (key /*: string*/, condition /*: string*/, value /*: mixed*/) /*: ParseQuery*/{\n      if (!this._where[key] || typeof this._where[key] === 'string') {\n        this._where[key] = {};\n      }\n      this._where[key][condition] = (0, _encode.default)(value, false, true);\n      return this;\n    }\n\n    /**\n     * Converts string for regular expression at the beginning\n     *\n     * @param string\n     * @returns {string}\n     */\n  }, {\n    key: \"_regexStartWith\",\n    value: function (string /*: string*/) /*: string*/{\n      return '^' + quote(string);\n    }\n  }, {\n    key: \"_handleOfflineQuery\",\n    value: function () {\n      var _handleOfflineQuery2 = (0, _asyncToGenerator2.default)( /*#__PURE__*/_regenerator.default.mark(function _callee(params /*: any*/) {\n        var _context,\n          _this2 = this;\n        var localDatastore, objects, results, keys, alwaysSelectedKeys, sorts, count, limit;\n        return _regenerator.default.wrap(function (_context3) {\n          while (1) switch (_context3.prev = _context3.next) {\n            case 0:\n              _OfflineQuery.default.validateQuery(this);\n              localDatastore = _CoreManager.default.getLocalDatastore();\n              _context3.next = 4;\n              return localDatastore._serializeObjectsFromPinName(this._localDatastorePinName);\n            case 4:\n              objects = _context3.sent;\n              results = (0, _filter2.default)(_context = (0, _map2.default)(objects).call(objects, function (json, index, arr) {\n                var object = _ParseObject.default.fromJSON(json, false);\n                if (json._localId && !json.objectId) {\n                  object._localId = json._localId;\n                }\n                if (!_OfflineQuery.default.matchesQuery(_this2.className, object, arr, _this2)) {\n                  return null;\n                }\n                return object;\n              })).call(_context, function (object) {\n                return object !== null;\n              });\n              if ((0, _keys2.default)(params)) {\n                keys = (0, _keys2.default)(params).split(',');\n                alwaysSelectedKeys = ['className', 'objectId', 'createdAt', 'updatedAt', 'ACL'];\n                keys = (0, _concat.default)(keys).call(keys, alwaysSelectedKeys);\n                results = (0, _map2.default)(results).call(results, function (object) {\n                  var _context2;\n                  var json = object._toFullJSON();\n                  (0, _forEach.default)(_context2 = (0, _keys.default)(json)).call(_context2, function (key) {\n                    if (!(0, _includes.default)(keys).call(keys, key)) {\n                      delete json[key];\n                    }\n                  });\n                  return _ParseObject.default.fromJSON(json, false);\n                });\n              }\n              if (params.order) {\n                sorts = params.order.split(',');\n                (0, _sort.default)(results).call(results, function (a, b) {\n                  return handleOfflineSort(a, b, sorts);\n                });\n              }\n              // count total before applying limit/skip\n              if (params.count) {\n                count = results.length; // total count from response\n              }\n\n              if (params.skip) {\n                if (params.skip >= results.length) {\n                  results = [];\n                } else {\n                  results = (0, _splice.default)(results).call(results, params.skip, results.length);\n                }\n              }\n              limit = results.length;\n              if (params.limit !== 0 && params.limit < results.length) {\n                limit = params.limit;\n              }\n              results = (0, _splice.default)(results).call(results, 0, limit);\n              if (!(typeof count === 'number')) {\n                _context3.next = 15;\n                break;\n              }\n              return _context3.abrupt(\"return\", {\n                results: results,\n                count: count\n              });\n            case 15:\n              return _context3.abrupt(\"return\", results);\n            case 16:\n            case \"end\":\n              return _context3.stop();\n          }\n        }, _callee, this);\n      }));\n      function _handleOfflineQuery() {\n        return _handleOfflineQuery2.apply(this, arguments);\n      }\n      return _handleOfflineQuery;\n    }()\n    /**\n     * Returns a JSON representation of this query.\n     *\n     * @returns {object} The JSON representation of the query.\n     */\n  }, {\n    key: \"toJSON\",\n    value: function () /*: QueryJSON*/{\n      var params /*: QueryJSON*/ = {\n        where: this._where\n      };\n      if (this._watch.length) {\n        params.watch = this._watch.join(',');\n      }\n      if (this._include.length) {\n        params.include = this._include.join(',');\n      }\n      if (this._exclude.length) {\n        params.excludeKeys = this._exclude.join(',');\n      }\n      if (this._select) {\n        params.keys = this._select.join(',');\n      }\n      if (this._count) {\n        params.count = 1;\n      }\n      if (this._limit >= 0) {\n        params.limit = this._limit;\n      }\n      if (this._skip > 0) {\n        params.skip = this._skip;\n      }\n      if (this._order) {\n        params.order = this._order.join(',');\n      }\n      if (this._readPreference) {\n        params.readPreference = this._readPreference;\n      }\n      if (this._includeReadPreference) {\n        params.includeReadPreference = this._includeReadPreference;\n      }\n      if (this._subqueryReadPreference) {\n        params.subqueryReadPreference = this._subqueryReadPreference;\n      }\n      if (this._hint) {\n        params.hint = this._hint;\n      }\n      if (this._explain) {\n        params.explain = true;\n      }\n      for (var _key3 in this._extraOptions) {\n        params[_key3] = this._extraOptions[_key3];\n      }\n      return params;\n    }\n\n    /**\n     * Return a query with conditions from json, can be useful to send query from server side to client\n     * Not static, all query conditions was set before calling this method will be deleted.\n     * For example on the server side we have\n     * var query = new Parse.Query(\"className\");\n     * query.equalTo(key: value);\n     * query.limit(100);\n     * ... (others queries)\n     * Create JSON representation of Query Object\n     * var jsonFromServer = query.fromJSON();\n     *\n     * On client side getting query:\n     * var query = new Parse.Query(\"className\");\n     * query.fromJSON(jsonFromServer);\n     *\n     * and continue to query...\n     * query.skip(100).find().then(...);\n     *\n     * @param {QueryJSON} json from Parse.Query.toJSON() method\n     * @returns {Parse.Query} Returns the query, so you can chain this call.\n     */\n  }, {\n    key: \"withJSON\",\n    value: function (json /*: QueryJSON*/) /*: ParseQuery*/{\n      if (json.where) {\n        this._where = json.where;\n      }\n      if (json.watch) {\n        this._watch = json.watch.split(',');\n      }\n      if (json.include) {\n        this._include = json.include.split(',');\n      }\n      if ((0, _keys2.default)(json)) {\n        this._select = (0, _keys2.default)(json).split(',');\n      }\n      if (json.excludeKeys) {\n        this._exclude = json.excludeKeys.split(',');\n      }\n      if (json.count) {\n        this._count = json.count === 1;\n      }\n      if (json.limit) {\n        this._limit = json.limit;\n      }\n      if (json.skip) {\n        this._skip = json.skip;\n      }\n      if (json.order) {\n        this._order = json.order.split(',');\n      }\n      if (json.readPreference) {\n        this._readPreference = json.readPreference;\n      }\n      if (json.includeReadPreference) {\n        this._includeReadPreference = json.includeReadPreference;\n      }\n      if (json.subqueryReadPreference) {\n        this._subqueryReadPreference = json.subqueryReadPreference;\n      }\n      if (json.hint) {\n        this._hint = json.hint;\n      }\n      if (json.explain) {\n        this._explain = !!json.explain;\n      }\n      for (var _key4 in json) {\n        if (json.hasOwnProperty(_key4)) {\n          var _context4;\n          if ((0, _indexOf.default)(_context4 = ['where', 'include', 'keys', 'count', 'limit', 'skip', 'order', 'readPreference', 'includeReadPreference', 'subqueryReadPreference', 'hint', 'explain']).call(_context4, _key4) === -1) {\n            this._extraOptions[_key4] = json[_key4];\n          }\n        }\n      }\n      return this;\n    }\n\n    /**\n     * Static method to restore Parse.Query by json representation\n     * Internally calling Parse.Query.withJSON\n     *\n     * @param {string} className\n     * @param {QueryJSON} json from Parse.Query.toJSON() method\n     * @returns {Parse.Query} new created query\n     */\n  }, {\n    key: \"get\",\n    value:\n    /**\n     * Constructs a Parse.Object whose id is already known by fetching data from\n     * the server. Unlike the <code>first</code> method, it never returns undefined.\n     *\n     * @param {string} objectId The id of the object to be fetched.\n     * @param {object} options\n     * Valid options are:<ul>\n     *   <li>useMasterKey: In Cloud Code and Node only, causes the Master Key to\n     *     be used for this request.\n     *   <li>sessionToken: A valid session token, used for making a request on\n     *       behalf of a specific user.\n     *   <li>context: A dictionary that is accessible in Cloud Code `beforeFind` trigger.\n     *   <li>json: Return raw json without converting to Parse.Object\n     * </ul>\n     * @returns {Promise} A promise that is resolved with the result when\n     * the query completes.\n     */\n    function (objectId /*: string*/, options /*:: ?: FullOptions*/) /*: Promise<ParseObject>*/{\n      this.equalTo('objectId', objectId);\n      var firstOptions = {};\n      if (options && options.hasOwnProperty('useMasterKey')) {\n        firstOptions.useMasterKey = options.useMasterKey;\n      }\n      if (options && options.hasOwnProperty('sessionToken')) {\n        firstOptions.sessionToken = options.sessionToken;\n      }\n      if (options && options.hasOwnProperty('context') && (0, _typeof2.default)(options.context) === 'object') {\n        firstOptions.context = options.context;\n      }\n      if (options && options.hasOwnProperty('json')) {\n        firstOptions.json = options.json;\n      }\n      return this.first(firstOptions).then(function (response) {\n        if (response) {\n          return response;\n        }\n        var errorObject = new _ParseError.default(_ParseError.default.OBJECT_NOT_FOUND, 'Object not found.');\n        return _promise.default.reject(errorObject);\n      });\n    }\n\n    /**\n     * Retrieves a list of ParseObjects that satisfy this query.\n     *\n     * @param {object} options Valid options\n     * are:<ul>\n     *   <li>useMasterKey: In Cloud Code and Node only, causes the Master Key to\n     *     be used for this request.\n     *   <li>sessionToken: A valid session token, used for making a request on\n     *       behalf of a specific user.\n     *   <li>context: A dictionary that is accessible in Cloud Code `beforeFind` trigger.\n     *   <li>json: Return raw json without converting to Parse.Object\n     * </ul>\n     * @returns {Promise} A promise that is resolved with the results when\n     * the query completes.\n     */\n  }, {\n    key: \"find\",\n    value: function (options /*:: ?: FullOptions*/) /*: Promise<Array<ParseObject>>*/{\n      var _this3 = this;\n      options = options || {};\n      var findOptions = {};\n      if (options.hasOwnProperty('useMasterKey')) {\n        findOptions.useMasterKey = options.useMasterKey;\n      }\n      if (options.hasOwnProperty('sessionToken')) {\n        findOptions.sessionToken = options.sessionToken;\n      }\n      if (options.hasOwnProperty('context') && (0, _typeof2.default)(options.context) === 'object') {\n        findOptions.context = options.context;\n      }\n      this._setRequestTask(findOptions);\n      var controller = _CoreManager.default.getQueryController();\n      var select = this._select;\n      if (this._queriesLocalDatastore) {\n        return this._handleOfflineQuery(this.toJSON());\n      }\n      return (0, _find.default)(controller).call(controller, this.className, this.toJSON(), findOptions).then(function (response) {\n        var _context5;\n        // Return generic object when explain is used\n        if (_this3._explain) {\n          return response.results;\n        }\n        var results = (0, _map2.default)(_context5 = response.results).call(_context5, function (data) {\n          // In cases of relations, the server may send back a className\n          // on the top level of the payload\n          var override = response.className || _this3.className;\n          if (!data.className) {\n            data.className = override;\n          }\n\n          // Make sure the data object contains keys for all objects that\n          // have been requested with a select, so that our cached state\n          // updates correctly.\n          if (select) {\n            handleSelectResult(data, select);\n          }\n          if (options.json) {\n            return data;\n          } else {\n            return _ParseObject.default.fromJSON(data, !select);\n          }\n        });\n        var count = response.count;\n        if (typeof count === 'number') {\n          return {\n            results: results,\n            count: count\n          };\n        } else {\n          return results;\n        }\n      });\n    }\n\n    /**\n     * Retrieves a complete list of ParseObjects that satisfy this query.\n     * Using `eachBatch` under the hood to fetch all the valid objects.\n     *\n     * @param {object} options Valid options are:<ul>\n     *   <li>batchSize: How many objects to yield in each batch (default: 100)\n     *   <li>useMasterKey: In Cloud Code and Node only, causes the Master Key to\n     *     be used for this request.\n     *   <li>sessionToken: A valid session token, used for making a request on\n     *       behalf of a specific user.\n     * </ul>\n     * @returns {Promise} A promise that is resolved with the results when\n     * the query completes.\n     */\n  }, {\n    key: \"findAll\",\n    value: function () {\n      var _findAll = (0, _asyncToGenerator2.default)( /*#__PURE__*/_regenerator.default.mark(function _callee2(options /*:: ?: BatchOptions*/) {\n        var result;\n        return _regenerator.default.wrap(function (_context7) {\n          while (1) switch (_context7.prev = _context7.next) {\n            case 0:\n              result /*: ParseObject[]*/ = [];\n              _context7.next = 3;\n              return this.eachBatch(function (objects /*: ParseObject[]*/) {\n                var _context6;\n                result = (0, _concat.default)(_context6 = []).call(_context6, (0, _toConsumableArray2.default)(result), (0, _toConsumableArray2.default)(objects));\n              }, options);\n            case 3:\n              return _context7.abrupt(\"return\", result);\n            case 4:\n            case \"end\":\n              return _context7.stop();\n          }\n        }, _callee2, this);\n      }));\n      function findAll() {\n        return _findAll.apply(this, arguments);\n      }\n      return findAll;\n    }()\n    /**\n     * Counts the number of objects that match this query.\n     *\n     * @param {object} options\n     * Valid options are:<ul>\n     *   <li>useMasterKey: In Cloud Code and Node only, causes the Master Key to\n     *     be used for this request.\n     *   <li>sessionToken: A valid session token, used for making a request on\n     *       behalf of a specific user.\n     * </ul>\n     * @returns {Promise} A promise that is resolved with the count when\n     * the query completes.\n     */\n  }, {\n    key: \"count\",\n    value: function (options /*:: ?: FullOptions*/) /*: Promise<number>*/{\n      options = options || {};\n      var findOptions = {};\n      if (options.hasOwnProperty('useMasterKey')) {\n        findOptions.useMasterKey = options.useMasterKey;\n      }\n      if (options.hasOwnProperty('sessionToken')) {\n        findOptions.sessionToken = options.sessionToken;\n      }\n      this._setRequestTask(findOptions);\n      var controller = _CoreManager.default.getQueryController();\n      var params = this.toJSON();\n      params.limit = 0;\n      params.count = 1;\n      return (0, _find.default)(controller).call(controller, this.className, params, findOptions).then(function (result) {\n        return result.count;\n      });\n    }\n\n    /**\n     * Executes a distinct query and returns unique values\n     *\n     * @param {string} key A field to find distinct values\n     * @param {object} options\n     * Valid options are:<ul>\n     *   <li>sessionToken: A valid session token, used for making a request on\n     *       behalf of a specific user.\n     * </ul>\n     * @returns {Promise} A promise that is resolved with the query completes.\n     */\n  }, {\n    key: \"distinct\",\n    value: function (key /*: string*/, options /*:: ?: FullOptions*/) /*: Promise<Array<mixed>>*/{\n      options = options || {};\n      var distinctOptions = {};\n      distinctOptions.useMasterKey = true;\n      if (options.hasOwnProperty('sessionToken')) {\n        distinctOptions.sessionToken = options.sessionToken;\n      }\n      this._setRequestTask(distinctOptions);\n      var controller = _CoreManager.default.getQueryController();\n      var params = {\n        distinct: key,\n        where: this._where,\n        hint: this._hint\n      };\n      return controller.aggregate(this.className, params, distinctOptions).then(function (results) {\n        return results.results;\n      });\n    }\n\n    /**\n     * Executes an aggregate query and returns aggregate results\n     *\n     * @param {(Array|object)} pipeline Array or Object of stages to process query\n     * @param {object} options Valid options are:<ul>\n     *   <li>sessionToken: A valid session token, used for making a request on\n     *       behalf of a specific user.\n     * </ul>\n     * @returns {Promise} A promise that is resolved with the query completes.\n     */\n  }, {\n    key: \"aggregate\",\n    value: function (pipeline /*: mixed*/, options /*:: ?: FullOptions*/) /*: Promise<Array<mixed>>*/{\n      options = options || {};\n      var aggregateOptions = {};\n      aggregateOptions.useMasterKey = true;\n      if (options.hasOwnProperty('sessionToken')) {\n        aggregateOptions.sessionToken = options.sessionToken;\n      }\n      this._setRequestTask(aggregateOptions);\n      var controller = _CoreManager.default.getQueryController();\n      if (!(0, _isArray.default)(pipeline) && (0, _typeof2.default)(pipeline) !== 'object') {\n        throw new Error('Invalid pipeline must be Array or Object');\n      }\n      if ((0, _keys.default)(this._where || {}).length) {\n        if (!(0, _isArray.default)(pipeline)) {\n          pipeline = [pipeline];\n        }\n        pipeline.unshift({\n          $match: this._where\n        });\n      }\n      var params = {\n        pipeline: pipeline,\n        hint: this._hint,\n        explain: this._explain,\n        readPreference: this._readPreference\n      };\n      return controller.aggregate(this.className, params, aggregateOptions).then(function (results) {\n        return results.results;\n      });\n    }\n\n    /**\n     * Retrieves at most one Parse.Object that satisfies this query.\n     *\n     * Returns the object if there is one, otherwise undefined.\n     *\n     * @param {object} options Valid options are:<ul>\n     *   <li>useMasterKey: In Cloud Code and Node only, causes the Master Key to\n     *     be used for this request.\n     *   <li>sessionToken: A valid session token, used for making a request on\n     *       behalf of a specific user.\n     *   <li>context: A dictionary that is accessible in Cloud Code `beforeFind` trigger.\n     *   <li>json: Return raw json without converting to Parse.Object\n     * </ul>\n     * @returns {Promise} A promise that is resolved with the object when\n     * the query completes.\n     */\n  }, {\n    key: \"first\",\n    value: function (options /*:: ?: FullOptions*/) /*: Promise<ParseObject | void>*/{\n      var _this4 = this;\n      options = options || {};\n      var findOptions = {};\n      if (options.hasOwnProperty('useMasterKey')) {\n        findOptions.useMasterKey = options.useMasterKey;\n      }\n      if (options.hasOwnProperty('sessionToken')) {\n        findOptions.sessionToken = options.sessionToken;\n      }\n      if (options.hasOwnProperty('context') && (0, _typeof2.default)(options.context) === 'object') {\n        findOptions.context = options.context;\n      }\n      this._setRequestTask(findOptions);\n      var controller = _CoreManager.default.getQueryController();\n      var params = this.toJSON();\n      params.limit = 1;\n      var select = this._select;\n      if (this._queriesLocalDatastore) {\n        return this._handleOfflineQuery(params).then(function (objects) {\n          if (!objects[0]) {\n            return undefined;\n          }\n          return objects[0];\n        });\n      }\n      return (0, _find.default)(controller).call(controller, this.className, params, findOptions).then(function (response) {\n        var objects = response.results;\n        if (!objects[0]) {\n          return undefined;\n        }\n        if (!objects[0].className) {\n          objects[0].className = _this4.className;\n        }\n\n        // Make sure the data object contains keys for all objects that\n        // have been requested with a select, so that our cached state\n        // updates correctly.\n        if (select) {\n          handleSelectResult(objects[0], select);\n        }\n        if (options.json) {\n          return objects[0];\n        } else {\n          return _ParseObject.default.fromJSON(objects[0], !select);\n        }\n      });\n    }\n\n    /**\n     * Iterates over objects matching a query, calling a callback for each batch.\n     * If the callback returns a promise, the iteration will not continue until\n     * that promise has been fulfilled. If the callback returns a rejected\n     * promise, then iteration will stop with that error. The items are processed\n     * in an unspecified order. The query may not have any sort order, and may\n     * not use limit or skip.\n     *\n     * @param {Function} callback Callback that will be called with each result\n     *     of the query.\n     * @param {object} options Valid options are:<ul>\n     *   <li>batchSize: How many objects to yield in each batch (default: 100)\n     *   <li>useMasterKey: In Cloud Code and Node only, causes the Master Key to\n     *     be used for this request.\n     *   <li>sessionToken: A valid session token, used for making a request on\n     *       behalf of a specific user.\n     *   <li>context: A dictionary that is accessible in Cloud Code `beforeFind` trigger.\n     * </ul>\n     * @returns {Promise} A promise that will be fulfilled once the\n     *     iteration has completed.\n     */\n  }, {\n    key: \"eachBatch\",\n    value: function (callback /*: (objs: Array<ParseObject>) => Promise<*>*/, options /*:: ?: BatchOptions*/) /*: Promise<void>*/{\n      var _context8;\n      options = options || {};\n      if (this._order || this._skip || this._limit >= 0) {\n        return _promise.default.reject('Cannot iterate on a query with sort, skip, or limit.');\n      }\n      var query = new ParseQuery(this.className);\n      query._limit = options.batchSize || 100;\n      query._include = (0, _map2.default)(_context8 = this._include).call(_context8, function (i) {\n        return i;\n      });\n      if (this._select) {\n        var _context9;\n        query._select = (0, _map2.default)(_context9 = this._select).call(_context9, function (s) {\n          return s;\n        });\n      }\n      query._hint = this._hint;\n      query._where = {};\n      for (var _attr in this._where) {\n        var val = this._where[_attr];\n        if ((0, _isArray.default)(val)) {\n          query._where[_attr] = (0, _map2.default)(val).call(val, function (v) {\n            return v;\n          });\n        } else if (val && (0, _typeof2.default)(val) === 'object') {\n          var conditionMap = {};\n          query._where[_attr] = conditionMap;\n          for (var cond in val) {\n            conditionMap[cond] = val[cond];\n          }\n        } else {\n          query._where[_attr] = val;\n        }\n      }\n      query.ascending('objectId');\n      var findOptions = {};\n      if (options.hasOwnProperty('useMasterKey')) {\n        findOptions.useMasterKey = options.useMasterKey;\n      }\n      if (options.hasOwnProperty('sessionToken')) {\n        findOptions.sessionToken = options.sessionToken;\n      }\n      if (options.hasOwnProperty('context') && (0, _typeof2.default)(options.context) === 'object') {\n        findOptions.context = options.context;\n      }\n      if (options.hasOwnProperty('json')) {\n        findOptions.json = options.json;\n      }\n      var finished = false;\n      var previousResults = [];\n      return (0, _promiseUtils.continueWhile)(function () {\n        return !finished;\n      }, /*#__PURE__*/(0, _asyncToGenerator2.default)( /*#__PURE__*/_regenerator.default.mark(function _callee3() {\n        var _yield$Promise$all, _yield$Promise$all2, results;\n        return _regenerator.default.wrap(function (_context10) {\n          while (1) switch (_context10.prev = _context10.next) {\n            case 0:\n              _context10.next = 2;\n              return _promise.default.all([(0, _find.default)(query).call(query, findOptions), _promise.default.resolve(previousResults.length > 0 && callback(previousResults))]);\n            case 2:\n              _yield$Promise$all = _context10.sent;\n              _yield$Promise$all2 = (0, _slicedToArray2.default)(_yield$Promise$all, 1);\n              results = _yield$Promise$all2[0];\n              if (!(results.length >= query._limit)) {\n                _context10.next = 10;\n                break;\n              }\n              query.greaterThan('objectId', results[results.length - 1].id);\n              previousResults = results;\n              _context10.next = 17;\n              break;\n            case 10:\n              if (!(results.length > 0)) {\n                _context10.next = 16;\n                break;\n              }\n              _context10.next = 13;\n              return _promise.default.resolve(callback(results));\n            case 13:\n              finished = true;\n              _context10.next = 17;\n              break;\n            case 16:\n              finished = true;\n            case 17:\n            case \"end\":\n              return _context10.stop();\n          }\n        }, _callee3);\n      })));\n    }\n\n    /**\n     * Iterates over each result of a query, calling a callback for each one. If\n     * the callback returns a promise, the iteration will not continue until\n     * that promise has been fulfilled. If the callback returns a rejected\n     * promise, then iteration will stop with that error. The items are\n     * processed in an unspecified order. The query may not have any sort order,\n     * and may not use limit or skip.\n     *\n     * @param {Function} callback Callback that will be called with each result\n     *     of the query.\n     * @param {object} options Valid options are:<ul>\n     *   <li>useMasterKey: In Cloud Code and Node only, causes the Master Key to\n     *     be used for this request.\n     *   <li>sessionToken: A valid session token, used for making a request on\n     *       behalf of a specific user.\n     *   <li>json: Return raw json without converting to Parse.Object\n     * </ul>\n     * @returns {Promise} A promise that will be fulfilled once the\n     *     iteration has completed.\n     */\n  }, {\n    key: \"each\",\n    value: function (callback /*: (obj: ParseObject) => any*/, options /*:: ?: BatchOptions*/) /*: Promise<void>*/{\n      return this.eachBatch(function (results) {\n        var callbacksDone = _promise.default.resolve();\n        (0, _forEach.default)(results).call(results, function (result) {\n          callbacksDone = callbacksDone.then(function () {\n            return callback(result);\n          });\n        });\n        return callbacksDone;\n      }, options);\n    }\n\n    /**\n     * Adds a hint to force index selection. (https://docs.mongodb.com/manual/reference/operator/meta/hint/)\n     *\n     * @param {(string|object)} value String or Object of index that should be used when executing query\n     * @returns {Parse.Query} Returns the query, so you can chain this call.\n     */\n  }, {\n    key: \"hint\",\n    value: function (value /*: mixed*/) /*: ParseQuery*/{\n      if (typeof value === 'undefined') {\n        delete this._hint;\n      }\n      this._hint = value;\n      return this;\n    }\n\n    /**\n     * Investigates the query execution plan. Useful for optimizing queries. (https://docs.mongodb.com/manual/reference/operator/meta/explain/)\n     *\n     * @param {boolean} explain Used to toggle the information on the query plan.\n     * @returns {Parse.Query} Returns the query, so you can chain this call.\n     */\n  }, {\n    key: \"explain\",\n    value: function () /*: ParseQuery*/{\n      var _explain /*: boolean*/ = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : true;\n      if (typeof _explain !== 'boolean') {\n        throw new Error('You can only set explain to a boolean value');\n      }\n      this._explain = _explain;\n      return this;\n    }\n\n    /**\n     * Iterates over each result of a query, calling a callback for each one. If\n     * the callback returns a promise, the iteration will not continue until\n     * that promise has been fulfilled. If the callback returns a rejected\n     * promise, then iteration will stop with that error. The items are\n     * processed in an unspecified order. The query may not have any sort order,\n     * and may not use limit or skip.\n     *\n     * @param {Function} callback Callback <ul>\n     *   <li>currentObject: The current Parse.Object being processed in the array.</li>\n     *   <li>index: The index of the current Parse.Object being processed in the array.</li>\n     *   <li>query: The query map was called upon.</li>\n     * </ul>\n     * @param {object} options Valid options are:<ul>\n     *   <li>useMasterKey: In Cloud Code and Node only, causes the Master Key to\n     *     be used for this request.\n     *   <li>sessionToken: A valid session token, used for making a request on\n     *       behalf of a specific user.\n     * </ul>\n     * @returns {Promise} A promise that will be fulfilled once the\n     *     iteration has completed.\n     */\n  }, {\n    key: \"map\",\n    value: function () {\n      var _map = (0, _asyncToGenerator2.default)( /*#__PURE__*/_regenerator.default.mark(function _callee4(callback /*: (currentObject: ParseObject, index: number, query: ParseQuery) => any*/, options /*:: ?: BatchOptions*/) {\n        var _this5 = this;\n        var array, index;\n        return _regenerator.default.wrap(function (_context11) {\n          while (1) switch (_context11.prev = _context11.next) {\n            case 0:\n              array = [];\n              index = 0;\n              _context11.next = 4;\n              return this.each(function (object) {\n                return _promise.default.resolve(callback(object, index, _this5)).then(function (result) {\n                  array.push(result);\n                  index += 1;\n                });\n              }, options);\n            case 4:\n              return _context11.abrupt(\"return\", array);\n            case 5:\n            case \"end\":\n              return _context11.stop();\n          }\n        }, _callee4, this);\n      }));\n      function map() {\n        return _map.apply(this, arguments);\n      }\n      return map;\n    }()\n    /**\n     * Iterates over each result of a query, calling a callback for each one. If\n     * the callback returns a promise, the iteration will not continue until\n     * that promise has been fulfilled. If the callback returns a rejected\n     * promise, then iteration will stop with that error. The items are\n     * processed in an unspecified order. The query may not have any sort order,\n     * and may not use limit or skip.\n     *\n     * @param {Function} callback Callback <ul>\n     *   <li>accumulator: The accumulator accumulates the callback's return values. It is the accumulated value previously returned in the last invocation of the callback.</li>\n     *   <li>currentObject: The current Parse.Object being processed in the array.</li>\n     *   <li>index: The index of the current Parse.Object being processed in the array.</li>\n     * </ul>\n     * @param {*} initialValue A value to use as the first argument to the first call of the callback. If no initialValue is supplied, the first object in the query will be used and skipped.\n     * @param {object} options Valid options are:<ul>\n     *   <li>useMasterKey: In Cloud Code and Node only, causes the Master Key to\n     *     be used for this request.\n     *   <li>sessionToken: A valid session token, used for making a request on\n     *       behalf of a specific user.\n     * </ul>\n     * @returns {Promise} A promise that will be fulfilled once the\n     *     iteration has completed.\n     */\n  }, {\n    key: \"reduce\",\n    value: function () {\n      var _reduce = (0, _asyncToGenerator2.default)( /*#__PURE__*/_regenerator.default.mark(function _callee5(callback /*: (accumulator: any, currentObject: ParseObject, index: number) => any*/, initialValue /*: any*/, options /*:: ?: BatchOptions*/) {\n        var accumulator, index;\n        return _regenerator.default.wrap(function (_context12) {\n          while (1) switch (_context12.prev = _context12.next) {\n            case 0:\n              accumulator = initialValue;\n              index = 0;\n              _context12.next = 4;\n              return this.each(function (object) {\n                // If no initial value was given, we take the first object from the query\n                // as the initial value and don't call the callback with it.\n                if (index === 0 && initialValue === undefined) {\n                  accumulator = object;\n                  index += 1;\n                  return;\n                }\n                return _promise.default.resolve(callback(accumulator, object, index)).then(function (result) {\n                  accumulator = result;\n                  index += 1;\n                });\n              }, options);\n            case 4:\n              if (!(index === 0 && initialValue === undefined)) {\n                _context12.next = 6;\n                break;\n              }\n              throw new TypeError('Reducing empty query result set with no initial value');\n            case 6:\n              return _context12.abrupt(\"return\", accumulator);\n            case 7:\n            case \"end\":\n              return _context12.stop();\n          }\n        }, _callee5, this);\n      }));\n      function reduce() {\n        return _reduce.apply(this, arguments);\n      }\n      return reduce;\n    }()\n    /**\n     * Iterates over each result of a query, calling a callback for each one. If\n     * the callback returns a promise, the iteration will not continue until\n     * that promise has been fulfilled. If the callback returns a rejected\n     * promise, then iteration will stop with that error. The items are\n     * processed in an unspecified order. The query may not have any sort order,\n     * and may not use limit or skip.\n     *\n     * @param {Function} callback Callback <ul>\n     *   <li>currentObject: The current Parse.Object being processed in the array.</li>\n     *   <li>index: The index of the current Parse.Object being processed in the array.</li>\n     *   <li>query: The query filter was called upon.</li>\n     * </ul>\n     * @param {object} options Valid options are:<ul>\n     *   <li>useMasterKey: In Cloud Code and Node only, causes the Master Key to\n     *     be used for this request.\n     *   <li>sessionToken: A valid session token, used for making a request on\n     *       behalf of a specific user.\n     * </ul>\n     * @returns {Promise} A promise that will be fulfilled once the\n     *     iteration has completed.\n     */\n  }, {\n    key: \"filter\",\n    value: function () {\n      var _filter = (0, _asyncToGenerator2.default)( /*#__PURE__*/_regenerator.default.mark(function _callee6(callback /*: (currentObject: ParseObject, index: number, query: ParseQuery) => boolean*/, options /*:: ?: BatchOptions*/) {\n        var _this6 = this;\n        var array, index;\n        return _regenerator.default.wrap(function (_context13) {\n          while (1) switch (_context13.prev = _context13.next) {\n            case 0:\n              array = [];\n              index = 0;\n              _context13.next = 4;\n              return this.each(function (object) {\n                return _promise.default.resolve(callback(object, index, _this6)).then(function (flag) {\n                  if (flag) {\n                    array.push(object);\n                  }\n                  index += 1;\n                });\n              }, options);\n            case 4:\n              return _context13.abrupt(\"return\", array);\n            case 5:\n            case \"end\":\n              return _context13.stop();\n          }\n        }, _callee6, this);\n      }));\n      function filter() {\n        return _filter.apply(this, arguments);\n      }\n      return filter;\n    }()\n    /* Query Conditions */\n    /**\n     * Adds a constraint to the query that requires a particular key's value to\n     * be equal to the provided value.\n     *\n     * @param {string} key The key to check.\n     * @param value The value that the Parse.Object must contain.\n     * @returns {Parse.Query} Returns the query, so you can chain this call.\n     */\n  }, {\n    key: \"equalTo\",\n    value: function (key /*: string | { [key: string]: any }*/, value /*: ?mixed*/) /*: ParseQuery*/{\n      var _this7 = this;\n      if (key && (0, _typeof2.default)(key) === 'object') {\n        var _context14;\n        (0, _forEach.default)(_context14 = (0, _entries.default)(key)).call(_context14, function (_ref2) {\n          var _ref3 = (0, _slicedToArray2.default)(_ref2, 2),\n            k = _ref3[0],\n            val = _ref3[1];\n          return _this7.equalTo(k, val);\n        });\n        return this;\n      }\n      if (typeof value === 'undefined') {\n        return this.doesNotExist(key);\n      }\n      this._where[key] = (0, _encode.default)(value, false, true);\n      return this;\n    }\n\n    /**\n     * Adds a constraint to the query that requires a particular key's value to\n     * be not equal to the provided value.\n     *\n     * @param {string} key The key to check.\n     * @param value The value that must not be equalled.\n     * @returns {Parse.Query} Returns the query, so you can chain this call.\n     */\n  }, {\n    key: \"notEqualTo\",\n    value: function (key /*: string | { [key: string]: any }*/, value /*: ?mixed*/) /*: ParseQuery*/{\n      var _this8 = this;\n      if (key && (0, _typeof2.default)(key) === 'object') {\n        var _context15;\n        (0, _forEach.default)(_context15 = (0, _entries.default)(key)).call(_context15, function (_ref4) {\n          var _ref5 = (0, _slicedToArray2.default)(_ref4, 2),\n            k = _ref5[0],\n            val = _ref5[1];\n          return _this8.notEqualTo(k, val);\n        });\n        return this;\n      }\n      return this._addCondition(key, '$ne', value);\n    }\n\n    /**\n     * Adds a constraint to the query that requires a particular key's value to\n     * be less than the provided value.\n     *\n     * @param {string} key The key to check.\n     * @param value The value that provides an upper bound.\n     * @returns {Parse.Query} Returns the query, so you can chain this call.\n     */\n  }, {\n    key: \"lessThan\",\n    value: function (key /*: string*/, value /*: mixed*/) /*: ParseQuery*/{\n      return this._addCondition(key, '$lt', value);\n    }\n\n    /**\n     * Adds a constraint to the query that requires a particular key's value to\n     * be greater than the provided value.\n     *\n     * @param {string} key The key to check.\n     * @param value The value that provides an lower bound.\n     * @returns {Parse.Query} Returns the query, so you can chain this call.\n     */\n  }, {\n    key: \"greaterThan\",\n    value: function (key /*: string*/, value /*: mixed*/) /*: ParseQuery*/{\n      return this._addCondition(key, '$gt', value);\n    }\n\n    /**\n     * Adds a constraint to the query that requires a particular key's value to\n     * be less than or equal to the provided value.\n     *\n     * @param {string} key The key to check.\n     * @param value The value that provides an upper bound.\n     * @returns {Parse.Query} Returns the query, so you can chain this call.\n     */\n  }, {\n    key: \"lessThanOrEqualTo\",\n    value: function (key /*: string*/, value /*: mixed*/) /*: ParseQuery*/{\n      return this._addCondition(key, '$lte', value);\n    }\n\n    /**\n     * Adds a constraint to the query that requires a particular key's value to\n     * be greater than or equal to the provided value.\n     *\n     * @param {string} key The key to check.\n     * @param {*} value The value that provides an lower bound.\n     * @returns {Parse.Query} Returns the query, so you can chain this call.\n     */\n  }, {\n    key: \"greaterThanOrEqualTo\",\n    value: function (key /*: string*/, value /*: mixed*/) /*: ParseQuery*/{\n      return this._addCondition(key, '$gte', value);\n    }\n\n    /**\n     * Adds a constraint to the query that requires a particular key's value to\n     * be contained in the provided list of values.\n     *\n     * @param {string} key The key to check.\n     * @param {Array<*>} value The values that will match.\n     * @returns {Parse.Query} Returns the query, so you can chain this call.\n     */\n  }, {\n    key: \"containedIn\",\n    value: function (key /*: string*/, value /*: Array<mixed>*/) /*: ParseQuery*/{\n      return this._addCondition(key, '$in', value);\n    }\n\n    /**\n     * Adds a constraint to the query that requires a particular key's value to\n     * not be contained in the provided list of values.\n     *\n     * @param {string} key The key to check.\n     * @param {Array<*>} value The values that will not match.\n     * @returns {Parse.Query} Returns the query, so you can chain this call.\n     */\n  }, {\n    key: \"notContainedIn\",\n    value: function (key /*: string*/, value /*: Array<mixed>*/) /*: ParseQuery*/{\n      return this._addCondition(key, '$nin', value);\n    }\n\n    /**\n     * Adds a constraint to the query that requires a particular key's value to\n     * be contained by the provided list of values. Get objects where all array elements match.\n     *\n     * @param {string} key The key to check.\n     * @param {Array} values The values that will match.\n     * @returns {Parse.Query} Returns the query, so you can chain this call.\n     */\n  }, {\n    key: \"containedBy\",\n    value: function (key /*: string*/, values /*: Array<mixed>*/) /*: ParseQuery*/{\n      return this._addCondition(key, '$containedBy', values);\n    }\n\n    /**\n     * Adds a constraint to the query that requires a particular key's value to\n     * contain each one of the provided list of values.\n     *\n     * @param {string} key The key to check.  This key's value must be an array.\n     * @param {Array} values The values that will match.\n     * @returns {Parse.Query} Returns the query, so you can chain this call.\n     */\n  }, {\n    key: \"containsAll\",\n    value: function (key /*: string*/, values /*: Array<mixed>*/) /*: ParseQuery*/{\n      return this._addCondition(key, '$all', values);\n    }\n\n    /**\n     * Adds a constraint to the query that requires a particular key's value to\n     * contain each one of the provided list of values starting with given strings.\n     *\n     * @param {string} key The key to check.  This key's value must be an array.\n     * @param {Array<string>} values The string values that will match as starting string.\n     * @returns {Parse.Query} Returns the query, so you can chain this call.\n     */\n  }, {\n    key: \"containsAllStartingWith\",\n    value: function (key /*: string*/, values /*: Array<string>*/) /*: ParseQuery*/{\n      var _this = this;\n      if (!(0, _isArray.default)(values)) {\n        values = [values];\n      }\n      var regexObject = (0, _map2.default)(values).call(values, function (value) {\n        return {\n          $regex: _this._regexStartWith(value)\n        };\n      });\n      return this.containsAll(key, regexObject);\n    }\n\n    /**\n     * Adds a constraint for finding objects that contain the given key.\n     *\n     * @param {string} key The key that should exist.\n     * @returns {Parse.Query} Returns the query, so you can chain this call.\n     */\n  }, {\n    key: \"exists\",\n    value: function (key /*: string*/) /*: ParseQuery*/{\n      return this._addCondition(key, '$exists', true);\n    }\n\n    /**\n     * Adds a constraint for finding objects that do not contain a given key.\n     *\n     * @param {string} key The key that should not exist\n     * @returns {Parse.Query} Returns the query, so you can chain this call.\n     */\n  }, {\n    key: \"doesNotExist\",\n    value: function (key /*: string*/) /*: ParseQuery*/{\n      return this._addCondition(key, '$exists', false);\n    }\n\n    /**\n     * Adds a regular expression constraint for finding string values that match\n     * the provided regular expression.\n     * This may be slow for large datasets.\n     *\n     * @param {string} key The key that the string to match is stored in.\n     * @param {RegExp} regex The regular expression pattern to match.\n     * @param {string} modifiers The regular expression mode.\n     * @returns {Parse.Query} Returns the query, so you can chain this call.\n     */\n  }, {\n    key: \"matches\",\n    value: function (key /*: string*/, regex /*: RegExp*/, modifiers /*: string*/) /*: ParseQuery*/{\n      this._addCondition(key, '$regex', regex);\n      if (!modifiers) {\n        modifiers = '';\n      }\n      if (regex.ignoreCase) {\n        modifiers += 'i';\n      }\n      if (regex.multiline) {\n        modifiers += 'm';\n      }\n      if (modifiers.length) {\n        this._addCondition(key, '$options', modifiers);\n      }\n      return this;\n    }\n\n    /**\n     * Adds a constraint that requires that a key's value matches a Parse.Query\n     * constraint.\n     *\n     * @param {string} key The key that the contains the object to match the\n     *                     query.\n     * @param {Parse.Query} query The query that should match.\n     * @returns {Parse.Query} Returns the query, so you can chain this call.\n     */\n  }, {\n    key: \"matchesQuery\",\n    value: function (key /*: string*/, query /*: ParseQuery*/) /*: ParseQuery*/{\n      var queryJSON = query.toJSON();\n      queryJSON.className = query.className;\n      return this._addCondition(key, '$inQuery', queryJSON);\n    }\n\n    /**\n     * Adds a constraint that requires that a key's value not matches a\n     * Parse.Query constraint.\n     *\n     * @param {string} key The key that the contains the object to match the\n     *                     query.\n     * @param {Parse.Query} query The query that should not match.\n     * @returns {Parse.Query} Returns the query, so you can chain this call.\n     */\n  }, {\n    key: \"doesNotMatchQuery\",\n    value: function (key /*: string*/, query /*: ParseQuery*/) /*: ParseQuery*/{\n      var queryJSON = query.toJSON();\n      queryJSON.className = query.className;\n      return this._addCondition(key, '$notInQuery', queryJSON);\n    }\n\n    /**\n     * Adds a constraint that requires that a key's value matches a value in\n     * an object returned by a different Parse.Query.\n     *\n     * @param {string} key The key that contains the value that is being\n     *                     matched.\n     * @param {string} queryKey The key in the objects returned by the query to\n     *                          match against.\n     * @param {Parse.Query} query The query to run.\n     * @returns {Parse.Query} Returns the query, so you can chain this call.\n     */\n  }, {\n    key: \"matchesKeyInQuery\",\n    value: function (key /*: string*/, queryKey /*: string*/, query /*: ParseQuery*/) /*: ParseQuery*/{\n      var queryJSON = query.toJSON();\n      queryJSON.className = query.className;\n      return this._addCondition(key, '$select', {\n        key: queryKey,\n        query: queryJSON\n      });\n    }\n\n    /**\n     * Adds a constraint that requires that a key's value not match a value in\n     * an object returned by a different Parse.Query.\n     *\n     * @param {string} key The key that contains the value that is being\n     *                     excluded.\n     * @param {string} queryKey The key in the objects returned by the query to\n     *                          match against.\n     * @param {Parse.Query} query The query to run.\n     * @returns {Parse.Query} Returns the query, so you can chain this call.\n     */\n  }, {\n    key: \"doesNotMatchKeyInQuery\",\n    value: function (key /*: string*/, queryKey /*: string*/, query /*: ParseQuery*/) /*: ParseQuery*/{\n      var queryJSON = query.toJSON();\n      queryJSON.className = query.className;\n      return this._addCondition(key, '$dontSelect', {\n        key: queryKey,\n        query: queryJSON\n      });\n    }\n\n    /**\n     * Adds a constraint for finding string values that contain a provided\n     * string.  This may be slow for large datasets.\n     *\n     * @param {string} key The key that the string to match is stored in.\n     * @param {string} substring The substring that the value must contain.\n     * @returns {Parse.Query} Returns the query, so you can chain this call.\n     */\n  }, {\n    key: \"contains\",\n    value: function (key /*: string*/, substring /*: string*/) /*: ParseQuery*/{\n      if (typeof substring !== 'string') {\n        throw new Error('The value being searched for must be a string.');\n      }\n      return this._addCondition(key, '$regex', quote(substring));\n    }\n\n    /**\n     * Adds a constraint for finding string values that contain a provided\n     * string. This may be slow for large datasets. Requires Parse-Server > 2.5.0\n     *\n     * In order to sort you must use select and ascending ($score is required)\n     *  <pre>\n     *   query.fullText('field', 'term');\n     *   query.ascending('$score');\n     *   query.select('$score');\n     *  </pre>\n     *\n     * To retrieve the weight / rank\n     *  <pre>\n     *   object->get('score');\n     *  </pre>\n     *\n     * You can define optionals by providing an object as a third parameter\n     *  <pre>\n     *   query.fullText('field', 'term', { language: 'es', diacriticSensitive: true });\n     *  </pre>\n     *\n     * @param {string} key The key that the string to match is stored in.\n     * @param {string} value The string to search\n     * @param {object} options (Optional)\n     * @param {string} options.language The language that determines the list of stop words for the search and the rules for the stemmer and tokenizer.\n     * @param {boolean} options.caseSensitive A boolean flag to enable or disable case sensitive search.\n     * @param {boolean} options.diacriticSensitive A boolean flag to enable or disable diacritic sensitive search.\n     * @returns {Parse.Query} Returns the query, so you can chain this call.\n     */\n  }, {\n    key: \"fullText\",\n    value: function (key /*: string*/, value /*: string*/, options /*: ?Object*/) /*: ParseQuery*/{\n      options = options || {};\n      if (!key) {\n        throw new Error('A key is required.');\n      }\n      if (!value) {\n        throw new Error('A search term is required');\n      }\n      if (typeof value !== 'string') {\n        throw new Error('The value being searched for must be a string.');\n      }\n      var fullOptions = {};\n      fullOptions.$term = value;\n      for (var option in options) {\n        switch (option) {\n          case 'language':\n            fullOptions.$language = options[option];\n            break;\n          case 'caseSensitive':\n            fullOptions.$caseSensitive = options[option];\n            break;\n          case 'diacriticSensitive':\n            fullOptions.$diacriticSensitive = options[option];\n            break;\n          default:\n            throw new Error(\"Unknown option: \".concat(option));\n        }\n      }\n      return this._addCondition(key, '$text', {\n        $search: fullOptions\n      });\n    }\n\n    /**\n     * Method to sort the full text search by text score\n     *\n     * @returns {Parse.Query} Returns the query, so you can chain this call.\n     */\n  }, {\n    key: \"sortByTextScore\",\n    value: function () {\n      this.ascending('$score');\n      this.select(['$score']);\n      return this;\n    }\n\n    /**\n     * Adds a constraint for finding string values that start with a provided\n     * string.  This query will use the backend index, so it will be fast even\n     * for large datasets.\n     *\n     * @param {string} key The key that the string to match is stored in.\n     * @param {string} prefix The substring that the value must start with.\n     * @param {string} modifiers The regular expression mode.\n     * @returns {Parse.Query} Returns the query, so you can chain this call.\n     */\n  }, {\n    key: \"startsWith\",\n    value: function (key /*: string*/, prefix /*: string*/, modifiers /*: string*/) /*: ParseQuery*/{\n      if (typeof prefix !== 'string') {\n        throw new Error('The value being searched for must be a string.');\n      }\n      return this.matches(key, this._regexStartWith(prefix), modifiers);\n    }\n\n    /**\n     * Adds a constraint for finding string values that end with a provided\n     * string.  This will be slow for large datasets.\n     *\n     * @param {string} key The key that the string to match is stored in.\n     * @param {string} suffix The substring that the value must end with.\n     * @param {string} modifiers The regular expression mode.\n     * @returns {Parse.Query} Returns the query, so you can chain this call.\n     */\n  }, {\n    key: \"endsWith\",\n    value: function (key /*: string*/, suffix /*: string*/, modifiers /*: string*/) /*: ParseQuery*/{\n      if (typeof suffix !== 'string') {\n        throw new Error('The value being searched for must be a string.');\n      }\n      return this.matches(key, quote(suffix) + '$', modifiers);\n    }\n\n    /**\n     * Adds a proximity based constraint for finding objects with key point\n     * values near the point given.\n     *\n     * @param {string} key The key that the Parse.GeoPoint is stored in.\n     * @param {Parse.GeoPoint} point The reference Parse.GeoPoint that is used.\n     * @returns {Parse.Query} Returns the query, so you can chain this call.\n     */\n  }, {\n    key: \"near\",\n    value: function (key /*: string*/, point /*: ParseGeoPoint*/) /*: ParseQuery*/{\n      if (!(point instanceof _ParseGeoPoint.default)) {\n        // Try to cast it as a GeoPoint\n        point = new _ParseGeoPoint.default(point);\n      }\n      return this._addCondition(key, '$nearSphere', point);\n    }\n\n    /**\n     * Adds a proximity based constraint for finding objects with key point\n     * values near the point given and within the maximum distance given.\n     *\n     * @param {string} key The key that the Parse.GeoPoint is stored in.\n     * @param {Parse.GeoPoint} point The reference Parse.GeoPoint that is used.\n     * @param {number} maxDistance Maximum distance (in radians) of results to return.\n     * @param {boolean} sorted A Bool value that is true if results should be\n     * sorted by distance ascending, false is no sorting is required,\n     * defaults to true.\n     * @returns {Parse.Query} Returns the query, so you can chain this call.\n     */\n  }, {\n    key: \"withinRadians\",\n    value: function (key /*: string*/, point /*: ParseGeoPoint*/, maxDistance /*: number*/, sorted /*: boolean*/) /*: ParseQuery*/{\n      if (sorted || sorted === undefined) {\n        this.near(key, point);\n        return this._addCondition(key, '$maxDistance', maxDistance);\n      } else {\n        return this._addCondition(key, '$geoWithin', {\n          $centerSphere: [[point.longitude, point.latitude], maxDistance]\n        });\n      }\n    }\n\n    /**\n     * Adds a proximity based constraint for finding objects with key point\n     * values near the point given and within the maximum distance given.\n     * Radius of earth used is 3958.8 miles.\n     *\n     * @param {string} key The key that the Parse.GeoPoint is stored in.\n     * @param {Parse.GeoPoint} point The reference Parse.GeoPoint that is used.\n     * @param {number} maxDistance Maximum distance (in miles) of results to return.\n     * @param {boolean} sorted A Bool value that is true if results should be\n     * sorted by distance ascending, false is no sorting is required,\n     * defaults to true.\n     * @returns {Parse.Query} Returns the query, so you can chain this call.\n     */\n  }, {\n    key: \"withinMiles\",\n    value: function (key /*: string*/, point /*: ParseGeoPoint*/, maxDistance /*: number*/, sorted /*: boolean*/) /*: ParseQuery*/{\n      return this.withinRadians(key, point, maxDistance / 3958.8, sorted);\n    }\n\n    /**\n     * Adds a proximity based constraint for finding objects with key point\n     * values near the point given and within the maximum distance given.\n     * Radius of earth used is 6371.0 kilometers.\n     *\n     * @param {string} key The key that the Parse.GeoPoint is stored in.\n     * @param {Parse.GeoPoint} point The reference Parse.GeoPoint that is used.\n     * @param {number} maxDistance Maximum distance (in kilometers) of results to return.\n     * @param {boolean} sorted A Bool value that is true if results should be\n     * sorted by distance ascending, false is no sorting is required,\n     * defaults to true.\n     * @returns {Parse.Query} Returns the query, so you can chain this call.\n     */\n  }, {\n    key: \"withinKilometers\",\n    value: function (key /*: string*/, point /*: ParseGeoPoint*/, maxDistance /*: number*/, sorted /*: boolean*/) /*: ParseQuery*/{\n      return this.withinRadians(key, point, maxDistance / 6371.0, sorted);\n    }\n\n    /**\n     * Adds a constraint to the query that requires a particular key's\n     * coordinates be contained within a given rectangular geographic bounding\n     * box.\n     *\n     * @param {string} key The key to be constrained.\n     * @param {Parse.GeoPoint} southwest\n     *     The lower-left inclusive corner of the box.\n     * @param {Parse.GeoPoint} northeast\n     *     The upper-right inclusive corner of the box.\n     * @returns {Parse.Query} Returns the query, so you can chain this call.\n     */\n  }, {\n    key: \"withinGeoBox\",\n    value: function (key /*: string*/, southwest /*: ParseGeoPoint*/, northeast /*: ParseGeoPoint*/) /*: ParseQuery*/{\n      if (!(southwest instanceof _ParseGeoPoint.default)) {\n        southwest = new _ParseGeoPoint.default(southwest);\n      }\n      if (!(northeast instanceof _ParseGeoPoint.default)) {\n        northeast = new _ParseGeoPoint.default(northeast);\n      }\n      this._addCondition(key, '$within', {\n        $box: [southwest, northeast]\n      });\n      return this;\n    }\n\n    /**\n     * Adds a constraint to the query that requires a particular key's\n     * coordinates be contained within and on the bounds of a given polygon.\n     * Supports closed and open (last point is connected to first) paths\n     *\n     * Polygon must have at least 3 points\n     *\n     * @param {string} key The key to be constrained.\n     * @param {Array} points Array of Coordinates / GeoPoints\n     * @returns {Parse.Query} Returns the query, so you can chain this call.\n     */\n  }, {\n    key: \"withinPolygon\",\n    value: function (key /*: string*/, points /*: Array<Array<number>>*/) /*: ParseQuery*/{\n      return this._addCondition(key, '$geoWithin', {\n        $polygon: points\n      });\n    }\n\n    /**\n     * Add a constraint to the query that requires a particular key's\n     * coordinates that contains a ParseGeoPoint\n     *\n     * @param {string} key The key to be constrained.\n     * @param {Parse.GeoPoint} point\n     * @returns {Parse.Query} Returns the query, so you can chain this call.\n     */\n  }, {\n    key: \"polygonContains\",\n    value: function (key /*: string*/, point /*: ParseGeoPoint*/) /*: ParseQuery*/{\n      return this._addCondition(key, '$geoIntersects', {\n        $point: point\n      });\n    }\n\n    /* Query Orderings */\n\n    /**\n     * Sorts the results in ascending order by the given key.\n     *\n     * @param {(string|string[])} keys The key to order by, which is a\n     * string of comma separated values, or an Array of keys, or multiple keys.\n     * @returns {Parse.Query} Returns the query, so you can chain this call.\n     */\n  }, {\n    key: \"ascending\",\n    value: function () /*: ParseQuery*/{\n      this._order = [];\n      for (var _len = arguments.length, keys = new Array(_len), _key5 = 0; _key5 < _len; _key5++) {\n        keys[_key5] = arguments[_key5];\n      }\n      return this.addAscending.apply(this, keys);\n    }\n\n    /**\n     * Sorts the results in ascending order by the given key,\n     * but can also add secondary sort descriptors without overwriting _order.\n     *\n     * @param {(string|string[])} keys The key to order by, which is a\n     * string of comma separated values, or an Array of keys, or multiple keys.\n     * @returns {Parse.Query} Returns the query, so you can chain this call.\n     */\n  }, {\n    key: \"addAscending\",\n    value: function () /*: ParseQuery*/{\n      var _this9 = this;\n      if (!this._order) {\n        this._order = [];\n      }\n      for (var _len2 = arguments.length, keys = new Array(_len2), _key6 = 0; _key6 < _len2; _key6++) {\n        keys[_key6] = arguments[_key6];\n      }\n      (0, _forEach.default)(keys).call(keys, function (key) {\n        var _context16;\n        if ((0, _isArray.default)(key)) {\n          key = key.join();\n        }\n        _this9._order = (0, _concat.default)(_context16 = _this9._order).call(_context16, key.replace(/\\s/g, '').split(','));\n      });\n      return this;\n    }\n\n    /**\n     * Sorts the results in descending order by the given key.\n     *\n     * @param {(string|string[])} keys The key to order by, which is a\n     * string of comma separated values, or an Array of keys, or multiple keys.\n     * @returns {Parse.Query} Returns the query, so you can chain this call.\n     */\n  }, {\n    key: \"descending\",\n    value: function () /*: ParseQuery*/{\n      this._order = [];\n      for (var _len3 = arguments.length, keys = new Array(_len3), _key7 = 0; _key7 < _len3; _key7++) {\n        keys[_key7] = arguments[_key7];\n      }\n      return this.addDescending.apply(this, keys);\n    }\n\n    /**\n     * Sorts the results in descending order by the given key,\n     * but can also add secondary sort descriptors without overwriting _order.\n     *\n     * @param {(string|string[])} keys The key to order by, which is a\n     * string of comma separated values, or an Array of keys, or multiple keys.\n     * @returns {Parse.Query} Returns the query, so you can chain this call.\n     */\n  }, {\n    key: \"addDescending\",\n    value: function () /*: ParseQuery*/{\n      var _this10 = this;\n      if (!this._order) {\n        this._order = [];\n      }\n      for (var _len4 = arguments.length, keys = new Array(_len4), _key8 = 0; _key8 < _len4; _key8++) {\n        keys[_key8] = arguments[_key8];\n      }\n      (0, _forEach.default)(keys).call(keys, function (key) {\n        var _context17, _context18;\n        if ((0, _isArray.default)(key)) {\n          key = key.join();\n        }\n        _this10._order = (0, _concat.default)(_context17 = _this10._order).call(_context17, (0, _map2.default)(_context18 = key.replace(/\\s/g, '').split(',')).call(_context18, function (k) {\n          return '-' + k;\n        }));\n      });\n      return this;\n    }\n\n    /* Query Options */\n\n    /**\n     * Sets the number of results to skip before returning any results.\n     * This is useful for pagination.\n     * Default is to skip zero results.\n     *\n     * @param {number} n the number of results to skip.\n     * @returns {Parse.Query} Returns the query, so you can chain this call.\n     */\n  }, {\n    key: \"skip\",\n    value: function (n /*: number*/) /*: ParseQuery*/{\n      if (typeof n !== 'number' || n < 0) {\n        throw new Error('You can only skip by a positive number');\n      }\n      this._skip = n;\n      return this;\n    }\n\n    /**\n     * Sets the limit of the number of results to return. The default limit is 100.\n     *\n     * @param {number} n the number of results to limit to.\n     * @returns {Parse.Query} Returns the query, so you can chain this call.\n     */\n  }, {\n    key: \"limit\",\n    value: function (n /*: number*/) /*: ParseQuery*/{\n      if (typeof n !== 'number') {\n        throw new Error('You can only set the limit to a numeric value');\n      }\n      this._limit = n;\n      return this;\n    }\n\n    /**\n     * Sets the flag to include with response the total number of objects satisfying this query,\n     * despite limits/skip. Might be useful for pagination.\n     * Note that result of this query will be wrapped as an object with\n     * `results`: holding {ParseObject} array and `count`: integer holding total number\n     *\n     * @param {boolean} includeCount false - disable, true - enable.\n     * @returns {Parse.Query} Returns the query, so you can chain this call.\n     */\n  }, {\n    key: \"withCount\",\n    value: function () /*: ParseQuery*/{\n      var includeCount /*: boolean*/ = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : true;\n      if (typeof includeCount !== 'boolean') {\n        throw new Error('You can only set withCount to a boolean value');\n      }\n      this._count = includeCount;\n      return this;\n    }\n    /**\n     * Includes nested Parse.Objects for the provided key.  You can use dot\n     * notation to specify which fields in the included object are also fetched.\n     *\n     * You can include all nested Parse.Objects by passing in '*'.\n     * Requires Parse Server 3.0.0+\n     * <pre>query.include('*');</pre>\n     *\n     * @param {...string|Array<string>} keys The name(s) of the key(s) to include.\n     * @returns {Parse.Query} Returns the query, so you can chain this call.\n     */\n  }, {\n    key: \"include\",\n    value: function () /*: ParseQuery*/{\n      var _this11 = this;\n      for (var _len5 = arguments.length, keys = new Array(_len5), _key9 = 0; _key9 < _len5; _key9++) {\n        keys[_key9] = arguments[_key9];\n      }\n      (0, _forEach.default)(keys).call(keys, function (key) {\n        if ((0, _isArray.default)(key)) {\n          var _context19;\n          _this11._include = (0, _concat.default)(_context19 = _this11._include).call(_context19, key);\n        } else {\n          _this11._include.push(key);\n        }\n      });\n      return this;\n    }\n\n    /**\n     * Includes all nested Parse.Objects one level deep.\n     *\n     * Requires Parse Server 3.0.0+\n     *\n     * @returns {Parse.Query} Returns the query, so you can chain this call.\n     */\n  }, {\n    key: \"includeAll\",\n    value: function () /*: ParseQuery*/{\n      return this.include('*');\n    }\n\n    /**\n     * Restricts the fields of the returned Parse.Objects to include only the\n     * provided keys.  If this is called multiple times, then all of the keys\n     * specified in each of the calls will be included.\n     *\n     * @param {...string|Array<string>} keys The name(s) of the key(s) to include.\n     * @returns {Parse.Query} Returns the query, so you can chain this call.\n     */\n  }, {\n    key: \"select\",\n    value: function () /*: ParseQuery*/{\n      var _this12 = this;\n      if (!this._select) {\n        this._select = [];\n      }\n      for (var _len6 = arguments.length, keys = new Array(_len6), _key10 = 0; _key10 < _len6; _key10++) {\n        keys[_key10] = arguments[_key10];\n      }\n      (0, _forEach.default)(keys).call(keys, function (key) {\n        if ((0, _isArray.default)(key)) {\n          var _context20;\n          _this12._select = (0, _concat.default)(_context20 = _this12._select).call(_context20, key);\n        } else {\n          _this12._select.push(key);\n        }\n      });\n      return this;\n    }\n\n    /**\n     * Restricts the fields of the returned Parse.Objects to all keys except the\n     * provided keys. Exclude takes precedence over select and include.\n     *\n     * Requires Parse Server 3.6.0+\n     *\n     * @param {...string|Array<string>} keys The name(s) of the key(s) to exclude.\n     * @returns {Parse.Query} Returns the query, so you can chain this call.\n     */\n  }, {\n    key: \"exclude\",\n    value: function () /*: ParseQuery*/{\n      var _this13 = this;\n      for (var _len7 = arguments.length, keys = new Array(_len7), _key11 = 0; _key11 < _len7; _key11++) {\n        keys[_key11] = arguments[_key11];\n      }\n      (0, _forEach.default)(keys).call(keys, function (key) {\n        if ((0, _isArray.default)(key)) {\n          var _context21;\n          _this13._exclude = (0, _concat.default)(_context21 = _this13._exclude).call(_context21, key);\n        } else {\n          _this13._exclude.push(key);\n        }\n      });\n      return this;\n    }\n\n    /**\n     * Restricts live query to trigger only for watched fields.\n     *\n     * Requires Parse Server 6.0.0+\n     *\n     * @param {...string|Array<string>} keys The name(s) of the key(s) to watch.\n     * @returns {Parse.Query} Returns the query, so you can chain this call.\n     */\n  }, {\n    key: \"watch\",\n    value: function () /*: ParseQuery*/{\n      var _this14 = this;\n      for (var _len8 = arguments.length, keys = new Array(_len8), _key12 = 0; _key12 < _len8; _key12++) {\n        keys[_key12] = arguments[_key12];\n      }\n      (0, _forEach.default)(keys).call(keys, function (key) {\n        if ((0, _isArray.default)(key)) {\n          var _context22;\n          _this14._watch = (0, _concat.default)(_context22 = _this14._watch).call(_context22, key);\n        } else {\n          _this14._watch.push(key);\n        }\n      });\n      return this;\n    }\n\n    /**\n     * Changes the read preference that the backend will use when performing the query to the database.\n     *\n     * @param {string} readPreference The read preference for the main query.\n     * @param {string} includeReadPreference The read preference for the queries to include pointers.\n     * @param {string} subqueryReadPreference The read preference for the sub queries.\n     * @returns {Parse.Query} Returns the query, so you can chain this call.\n     */\n  }, {\n    key: \"readPreference\",\n    value: function (_readPreference /*: string*/, includeReadPreference /*:: ?: string*/, subqueryReadPreference /*:: ?: string*/) /*: ParseQuery*/{\n      this._readPreference = _readPreference;\n      this._includeReadPreference = includeReadPreference;\n      this._subqueryReadPreference = subqueryReadPreference;\n      return this;\n    }\n\n    /**\n     * Subscribe this query to get liveQuery updates\n     *\n     * @param {string} sessionToken (optional) Defaults to the currentUser\n     * @returns {Promise<LiveQuerySubscription>} Returns the liveQuerySubscription, it's an event emitter\n     * which can be used to get liveQuery updates.\n     */\n  }, {\n    key: \"subscribe\",\n    value: function () {\n      var _subscribe = (0, _asyncToGenerator2.default)( /*#__PURE__*/_regenerator.default.mark(function _callee7(sessionToken /*:: ?: string*/) {\n        var currentUser, liveQueryClient, subscription;\n        return _regenerator.default.wrap(function (_context23) {\n          while (1) switch (_context23.prev = _context23.next) {\n            case 0:\n              _context23.next = 2;\n              return _CoreManager.default.getUserController().currentUserAsync();\n            case 2:\n              currentUser = _context23.sent;\n              if (!sessionToken) {\n                sessionToken = currentUser ? currentUser.getSessionToken() : undefined;\n              }\n              _context23.next = 6;\n              return _CoreManager.default.getLiveQueryController().getDefaultLiveQueryClient();\n            case 6:\n              liveQueryClient = _context23.sent;\n              if (liveQueryClient.shouldOpen()) {\n                liveQueryClient.open();\n              }\n              subscription = liveQueryClient.subscribe(this, sessionToken);\n              return _context23.abrupt(\"return\", subscription.subscribePromise.then(function () {\n                return subscription;\n              }));\n            case 10:\n            case \"end\":\n              return _context23.stop();\n          }\n        }, _callee7, this);\n      }));\n      function subscribe() {\n        return _subscribe.apply(this, arguments);\n      }\n      return subscribe;\n    }()\n    /**\n     * Constructs a Parse.Query that is the OR of the passed in queries.  For\n     * example:\n     * <pre>var compoundQuery = Parse.Query.or(query1, query2, query3);</pre>\n     *\n     * will create a compoundQuery that is an or of the query1, query2, and\n     * query3.\n     *\n     * @param {...Parse.Query} queries The list of queries to OR.\n     * @static\n     * @returns {Parse.Query} The query that is the OR of the passed in queries.\n     */\n  }, {\n    key: \"fromNetwork\",\n    value:\n    /**\n     * Change the source of this query to the server.\n     *\n     * @returns {Parse.Query} Returns the query, so you can chain this call.\n     */\n    function () /*: ParseQuery*/{\n      this._queriesLocalDatastore = false;\n      this._localDatastorePinName = null;\n      return this;\n    }\n\n    /**\n     * Changes the source of this query to all pinned objects.\n     *\n     * @returns {Parse.Query} Returns the query, so you can chain this call.\n     */\n  }, {\n    key: \"fromLocalDatastore\",\n    value: function () /*: ParseQuery*/{\n      return this.fromPinWithName(null);\n    }\n\n    /**\n     * Changes the source of this query to the default group of pinned objects.\n     *\n     * @returns {Parse.Query} Returns the query, so you can chain this call.\n     */\n  }, {\n    key: \"fromPin\",\n    value: function () /*: ParseQuery*/{\n      return this.fromPinWithName(_LocalDatastoreUtils.DEFAULT_PIN);\n    }\n\n    /**\n     * Changes the source of this query to a specific group of pinned objects.\n     *\n     * @param {string} name The name of query source.\n     * @returns {Parse.Query} Returns the query, so you can chain this call.\n     */\n  }, {\n    key: \"fromPinWithName\",\n    value: function (name /*:: ?: string*/) /*: ParseQuery*/{\n      var localDatastore = _CoreManager.default.getLocalDatastore();\n      if (localDatastore.checkIfEnabled()) {\n        this._queriesLocalDatastore = true;\n        this._localDatastorePinName = name;\n      }\n      return this;\n    }\n\n    /**\n     * Cancels the current network request (if any is running).\n     *\n     * @returns {Parse.Query} Returns the query, so you can chain this call.\n     */\n  }, {\n    key: \"cancel\",\n    value: function () /*: ParseQuery*/{\n      var _this15 = this;\n      if (this._xhrRequest.task && typeof this._xhrRequest.task.abort === 'function') {\n        this._xhrRequest.task._aborted = true;\n        this._xhrRequest.task.abort();\n        this._xhrRequest.task = null;\n        this._xhrRequest.onchange = function () {};\n        return this;\n      }\n      return this._xhrRequest.onchange = function () {\n        return _this15.cancel();\n      };\n    }\n  }, {\n    key: \"_setRequestTask\",\n    value: function (options) {\n      var _this16 = this;\n      options.requestTask = function (task) {\n        _this16._xhrRequest.task = task;\n        _this16._xhrRequest.onchange();\n      };\n    }\n  }], [{\n    key: \"fromJSON\",\n    value: function (className /*: string*/, json /*: QueryJSON*/) /*: ParseQuery*/{\n      var query = new ParseQuery(className);\n      return query.withJSON(json);\n    }\n  }, {\n    key: \"or\",\n    value: function () /*: ParseQuery*/{\n      for (var _len9 = arguments.length, queries = new Array(_len9), _key13 = 0; _key13 < _len9; _key13++) {\n        queries[_key13] = arguments[_key13];\n      }\n      var className = _getClassNameFromQueries(queries);\n      var query = new ParseQuery(className);\n      query._orQuery(queries);\n      return query;\n    }\n\n    /**\n     * Constructs a Parse.Query that is the AND of the passed in queries.  For\n     * example:\n     * <pre>var compoundQuery = Parse.Query.and(query1, query2, query3);</pre>\n     *\n     * will create a compoundQuery that is an and of the query1, query2, and\n     * query3.\n     *\n     * @param {...Parse.Query} queries The list of queries to AND.\n     * @static\n     * @returns {Parse.Query} The query that is the AND of the passed in queries.\n     */\n  }, {\n    key: \"and\",\n    value: function () /*: ParseQuery*/{\n      for (var _len10 = arguments.length, queries = new Array(_len10), _key14 = 0; _key14 < _len10; _key14++) {\n        queries[_key14] = arguments[_key14];\n      }\n      var className = _getClassNameFromQueries(queries);\n      var query = new ParseQuery(className);\n      query._andQuery(queries);\n      return query;\n    }\n\n    /**\n     * Constructs a Parse.Query that is the NOR of the passed in queries.  For\n     * example:\n     * <pre>const compoundQuery = Parse.Query.nor(query1, query2, query3);</pre>\n     *\n     * will create a compoundQuery that is a nor of the query1, query2, and\n     * query3.\n     *\n     * @param {...Parse.Query} queries The list of queries to NOR.\n     * @static\n     * @returns {Parse.Query} The query that is the NOR of the passed in queries.\n     */\n  }, {\n    key: \"nor\",\n    value: function () /*: ParseQuery*/{\n      for (var _len11 = arguments.length, queries = new Array(_len11), _key15 = 0; _key15 < _len11; _key15++) {\n        queries[_key15] = arguments[_key15];\n      }\n      var className = _getClassNameFromQueries(queries);\n      var query = new ParseQuery(className);\n      query._norQuery(queries);\n      return query;\n    }\n  }]);\n  return ParseQuery;\n}();\nvar DefaultController = {\n  find: function (className /*: string*/, params /*: QueryJSON*/, options /*: RequestOptions*/) /*: Promise<Array<ParseObject>>*/{\n    var RESTController = _CoreManager.default.getRESTController();\n    return RESTController.request('GET', 'classes/' + className, params, options);\n  },\n  aggregate: function (className /*: string*/, params /*: any*/, options /*: RequestOptions*/) /*: Promise<Array<mixed>>*/{\n    var RESTController = _CoreManager.default.getRESTController();\n    return RESTController.request('GET', 'aggregate/' + className, params, options);\n  }\n};\n_CoreManager.default.setQueryController(DefaultController);\nvar _default = ParseQuery;\nexports.default = _default;"],"mappings":"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"},"metadata":{},"sourceType":"script","externalDependencies":[]}